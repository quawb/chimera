<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chimera â€” Warband Builder (Prototype)</title>

  <style>
    /* Dice animation */
    .dice-result { display: inline-block; min-width: 2ch; }
    .dice-rolling { animation: diceSpin 0.45s ease-in-out; }
    @keyframes diceSpin {
      0%   { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
      25%  { transform: translateY(-4px) rotate(6deg) scale(1.08); opacity: 0.9; }
      50%  { transform: translateY(2px) rotate(-6deg) scale(0.98); opacity: 0.9; }
      75%  { transform: translateY(-2px) rotate(3deg) scale(1.04); opacity: 1; }
      100% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 24px;
      line-height: 1.35;
    }
    h1 { margin: 0 0 8px; }
    .sub { color: #444; margin: 0 0 24px; }

    .row {
      display: grid;
      grid-template-columns: 240px 1fr;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
    }

    select, input { font-size: 16px; padding: 8px; }

    .card {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 14px;
      margin-top: 16px;
      max-width: none;
    }

    .grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      align-items: start;
      margin-top: 12px;
    }

    .pill {
      display: inline-block;
      border: 1px solid #ddd;
      border-radius: 999px;
      padding: 4px 10px;
      margin: 4px 6px 0 0;
      font-size: 14px;
    }
    .warn { color: #8a1f11; font-weight: 600; }
    .ok { color: #0b5; font-weight: 600; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }

    #warbandGrid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      align-items: start;
    }
    #warbandGrid > div { min-width: 0; overflow: hidden; }
    #warbandGrid input, #warbandGrid select, #warbandGrid button {
      max-width: 100%;
      box-sizing: border-box;
    }
    #warbandGrid > div > div:first-child { flex-wrap: wrap; }

    #warbandName { max-width: 280px; padding: 6px 8px; font-size: 14px; }
    #pointCap { max-width: 96px; padding: 6px 8px; font-size: 14px; }
    /* Make trait descriptions span full row (prevents odd wrapping / overflow) */
    #warbandTraitDesc,
    #leaderTraitDesc {
  grid-column: 1 / -1;
  max-width: 100%;
}


    /* --- Compact mode --- */
    body.compact { margin: 16px; }
    body.compact .row { grid-template-columns: 140px 1fr; gap: 10px; margin-bottom: 8px; }
    body.compact select, body.compact input { font-size: 14px; padding: 6px 8px; }
    body.compact #warbandGrid { gap: 10px; }
    body.compact #warbandGrid > div { padding: 10px !important; }
    body.compact #warbandGrid > div > div { margin-top: 8px !important; }

    /* Compact: "read at a glance" per-model summary */
body.compact .compactHeadline{
  display: grid;
  grid-template-columns: 1fr;   /* 2 columns on phone */
  gap: 6px 10px;
  font-size: 12px;
  line-height: 1.15;
  background: #fff;
  border: 1px solid #eee;
  border-radius: 10px;
  padding: 8px;
}
body.compact .compactHeadline{
  border: 1px solid #e8e8e8;
  box-shadow: 0 1px 2px rgba(0,0,0,.04);
}


body.compact .compactHeadline .kv{
  min-width: 0;
}

body.compact .compactHeadline .k{
  display: block;
  font-weight: 800;
  font-size: 11px;
  color: #444;
  margin-bottom: 2px;
}

body.compact .compactHeadline .v{
  display: block;
  font-weight: 700;
  color: #111;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis; /* keeps it inside the card */
}

/* When the value is long (accessories/powers), allow wrapping instead of overflow */
body.compact .compactHeadline .v.wrap{
  white-space: pre-wrap;
  overflow: visible;
  text-overflow: unset;
}



/* --- In-play controls: Wounds + Horror always on their own lines --- */
/* Label + one pill, pill starts right after label */
/* label + pill */
.playrow{
  display: grid;
  grid-template-columns: 84px 1fr;
  gap: 10px;
  align-items: center;
  min-width: 0;
}

/* segmented pill */
.counter{
  display: grid;
  grid-template-columns: 34px 1fr 34px auto; /* - | value | + | Full/Clear */
  align-items: stretch;
  border: 1px solid #ddd;
  border-radius: 999px;
  overflow: hidden;              /* âœ… forces Full/Clear to be fully "inside" */
  background: #fff;
  min-width: 0;
}

.counter .val{
  display: grid;
  place-items: center;
  font-weight: 900;
  font-size: 14px;
  min-width: 0;
  padding: 0 8px;
}

/* the -/+ segments */
.counter .ctrBtn{
  border: 0;
  background: transparent;
  cursor: pointer;
  font-weight: 900;
  font-size: 16px;
  line-height: 1;
}

/* Full/Clear segment */
.counter .ctrExtra{
  border: 0;
  border-left: 1px solid #ddd;   /* divider inside pill */
  background: #fff;
  cursor: pointer;
  font-weight: 800;
  font-size: 12px;
  padding: 0 12px;
  white-space: nowrap;
}

/* subtle hover */
.counter .ctrBtn:hover,
.counter .ctrExtra:hover{
  background: #f3f3f3;
}

/* small screens: stack label above pill */
@media (max-width: 640px){
  .playrow{ grid-template-columns: 1fr; align-items: stretch; }
}



    /* Card visibility toggles */
    #modelVisibility {
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid #eee;
      border-radius: 10px;
      background: #fafafa;
    }
    #modelVisibility .mvGrid{
      margin-top: 8px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 8px 12px;
    }
    #modelVisibility label{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
      font-size: 13px;
      color:#333;
    }

    /* ---------- Mobile / small screens ---------- */
@media (max-width: 640px) {
  body { margin: 12px; }

  /* Stack label + control instead of 240px label column */
  .row {
    grid-template-columns: 1fr;
    gap: 6px;
  }

  /* Inputs stop being artificially narrow */
  #warbandName,
  #pointCap {
    max-width: none;
    width: 100%;
  }

  /* Model cards / grids: allow narrower columns */
  #warbandGrid {
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  }

  /* In-play tracker bars: stack instead of 2-up */
  .playbar {
    grid-template-columns: 1fr;
  }

  .playrow {
    flex-wrap: wrap;
    justify-content: flex-start;
  }

  .counter {
    width: 100%;
    justify-content: space-between;
  }

  .counter .val {
    min-width: 36px;
  }

  /* Optional: make the extra button (Full/Clear) not squeeze layout */
  .smallBtn {
    width: 100%;
  }
}
/* Compact: at-a-glance model summary (no horizontal spill) */
body.compact .compactHeadline{
  display: grid;
  grid-template-columns: 1fr;
  gap: 6px 10px;
  font-size: 12px;
  line-height: 1.15;
  background: #fff;
  border: 1px solid #eee;
  border-radius: 10px;
  padding: 8px;
  margin-top: 8px;
}

body.compact .compactHeadline .kv{ min-width: 0; }

body.compact .compactHeadline .k{
  display: block;
  font-weight: 800;
  font-size: 11px;
  color: #444;
  margin-bottom: 2px;
}

body.compact .compactHeadline .v{
  display: block;
  font-weight: 700;
  color: #111;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

body.compact .compactHeadline .v.wrap{
  white-space: pre-wrap;   /* âœ… preserves \n line breaks */
  overflow: visible;
  text-overflow: unset;
}


  </style>
</head>

<body>
  <h1>Chimera Builder</h1>

    <div class="sub">
    <a href="./rules.html">Rules</a>
  </div>

  <div class="sub">
    <a href="./sandbox.html">Sandbox</a>
  </div>

    <div class="card" style="margin-top:12px;">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div style="font-weight:900;">Dice</div>

      <button id="rollD20Btn" type="button"
        style="padding:8px 12px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer;">
        Roll d20
      </button>

      <div style="display:flex; gap:8px; align-items:baseline;">
        <div style="color:#666;">Result</div>
        <div id="d20Result" class="dice-result" style="font-size:22px; font-weight:900;">â€”</div>
      </div>

      <button id="clearRollsBtn" type="button"
        style="padding:8px 12px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer;">
        Clear
      </button>
    </div>

    <div id="d20History" style="margin-top:10px; color:#444; font-size:14px;"></div>
  </div>

  <div class="row">
    <label for="pointCap"><strong>Point Cap</strong></label>
    <input id="pointCap" type="number" value="75" min="0" step="1" />
  </div>

  <div class="row" style="margin-top:10px;">
    <label><strong>Display</strong></label>
    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none;">
      <input id="compactToggle" type="checkbox" />
      Compact mode
    </label>
  </div>

  <div class="card">
    <div style="display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center;">
      <div>
        <div style="font-size:18px; font-weight:800;"></div>
        <div style="color:#444; margin-top:4px;"></div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="exportBtn" type="button">Export Warband</button>
        <button id="importBtn" type="button">Import Warband</button>
        <button id="randomWarbandBtn" type="button">ðŸŽ² Random Warband</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="warbandName"><strong>Warband Name</strong></label>
      <input id="warbandName" type="text" placeholder="e.g., The Quawb Cult" style="width:100%;" />
    </div>

        <!-- NEW: per-model show/hide -->
    <div id="modelVisibility" style="display:none;">
      <div style="font-weight:900;">Show / hide model cards</div>
      <div class="mvGrid" id="modelVisibilityGrid"></div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="warbandTraitSelect"><strong>Warband Trait</strong></label>
      <select id="warbandTraitSelect"></select>
      <div id="warbandTraitDesc" style="margin-top:6px; color:#444; font-size:13px;"></div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="leaderTraitSelect"><strong>Leader Trait</strong></label>
      <select id="leaderTraitSelect"></select>
      <div id="leaderTraitDesc" style="margin-top:6px; color:#444; font-size:13px;"></div>
    </div>

    <div id="warbandGrid" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; margin-top:14px;"></div>

    <div style="margin-top:14px;">
      <div style="font-size:14px; color:#444;">Warband Total</div>
      <div style="font-size:28px; font-weight:900;" id="warbandTotal">0</div>
      <div id="warbandCapStatus" style="margin-top:6px;"></div>
    </div>

    <div id="ioArea" style="display:none; margin-top:14px;">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
        <strong id="ioTitle">Export / Import</strong>
        <button id="closeIoBtn" type="button">Close</button>
      </div>
      <textarea id="ioText" rows="10" style="width:100%; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; padding:10px;"></textarea>
      <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
        <button id="copyBtn" type="button">Copy</button>
        <button id="loadBtn" type="button">Load Pasted JSON</button>
      </div>
      <div id="ioMsg" style="margin-top:8px; color:#444;"></div>
    </div>
  </div>

  <div class="card" id="errorCard" style="display:none;">
    <div class="warn">Could not load shoot.json</div>
    <p id="errorText" style="margin:8px 0 0;"></p>
    <p style="margin:8px 0 0;">
      Expected path: <code>data/shoot.json</code>
    </p>
  </div>

<script>
  const els = {
    rollD20Btn: document.getElementById("rollD20Btn"),
    clearRollsBtn: document.getElementById("clearRollsBtn"),
    d20Result: document.getElementById("d20Result"),
    d20History: document.getElementById("d20History"),

    compactToggle: document.getElementById("compactToggle"),
    warbandName: document.getElementById("warbandName"),

    pointCap: document.getElementById("pointCap"),
    warbandGrid: document.getElementById("warbandGrid"),
    warbandTotal: document.getElementById("warbandTotal"),
    warbandCapStatus: document.getElementById("warbandCapStatus"),

    warbandTraitSelect: document.getElementById("warbandTraitSelect"),
    leaderTraitSelect: document.getElementById("leaderTraitSelect"),
    warbandTraitDesc: document.getElementById("warbandTraitDesc"),
    leaderTraitDesc: document.getElementById("leaderTraitDesc"),

    exportBtn: document.getElementById("exportBtn"),
    importBtn: document.getElementById("importBtn"),
    randomWarbandBtn: document.getElementById("randomWarbandBtn"),
    ioArea: document.getElementById("ioArea"),
    ioTitle: document.getElementById("ioTitle"),
    ioText: document.getElementById("ioText"),
    copyBtn: document.getElementById("copyBtn"),
    loadBtn: document.getElementById("loadBtn"),
    closeIoBtn: document.getElementById("closeIoBtn"),
    ioMsg: document.getElementById("ioMsg"),

    modelVisibility: document.getElementById("modelVisibility"),
    modelVisibilityGrid: document.getElementById("modelVisibilityGrid"),

    errorCard: document.getElementById("errorCard"),
    errorText: document.getElementById("errorText"),
  };

  const diceState = { history: [] }; // newest first
  let d20FlickerTimer = null;
let d20FinalTimer = null;
let d20RollToken = 0;

  function rollDie(sides) { return Math.floor(Math.random() * sides) + 1; }
  function renderDice() {
    if (!els.d20History) return;
    els.d20History.textContent = diceState.history.length
      ? "History: " + diceState.history.join(", ")
      : "History: â€”";
  }

  function toIntOrNull(v) {
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (s === "") return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  // ---------- Random name + loadout helpers ----------
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

const SILLY_FIRST = [
  "Bob", "Smokey", "Gummy", "Fizzy", "Cranky", "Spicy", "Wobble", "Soggy", "Porkchop", "Mister", "Doctor",
  "Grub", "Biscuit", "Doodle", "Noodle", "Pickle", "Beans", "Honk", "Goober", "Zappy", "Moldy", "Captain"
];
const SILLY_LAST = [
  "the Blob", "the Bear", "the Unwise", "the Damp", "the Loud", "the Unforgiven", "the Greasy", "the Gentle",
  "the Infinite", "the Suspicious", "the Mildly Haunted", "the Crunchy", "the Misplaced", "the Wretched",
  "of Westchester", "of the Sewer", "from Accounting", "the Knife-Collector", "the Rust King", "the Moon-Licker"
];
const SILLY_ROLE = [
  "Warden", "Janitor", "Oracle", "Squire", "Bouncer", "Archivist", "Fence", "Cook", "Scout", "Prophet", "Clerk"
];

const WARBAND_PREFIX = [
  "The", "The Honorable", "The Questionable", "The Blessed", "The Cursed", "The Extremely Normal"
];
const WARBAND_ADJ = [
  "Quawb", "Sewer", "Gutter", "Moon", "Rust", "Mold", "Neon", "Bone", "Goo", "Ferret", "Goblin", "Liminal"
];
const WARBAND_NOUN = [
  "Cult", "Union", "Cabal", "Choir", "Committee", "Collective", "Crew", "Squad", "Coven", "Congregation", "Society"
];

function randomWarbandName() {
  // e.g. "The Neon Cabal", "The Questionable Rust Union"
  return `${pick(WARBAND_PREFIX)} ${pick(WARBAND_ADJ)} ${pick(WARBAND_NOUN)}`;
}

function randomModelName(role) {
  // e.g. "Bob the Blob", "Captain Pickle the Mildly Haunted"
  const style = randInt(1, 3);
  if (style === 1) return `${pick(SILLY_FIRST)} ${pick(SILLY_LAST)}`;
  if (style === 2) return `${pick(SILLY_FIRST)} ${pick(SILLY_ROLE)}`;
  return `${pick(SILLY_FIRST)} ${pick(SILLY_FIRST).toLowerCase()} ${pick(SILLY_LAST)}`;
}

function itemPoints(obj) { return toIntOrNull(obj?.points) ?? 0; }


  // UI preferences
  const uiPrefs = { compact: false };
  function applyCompactMode(on) {
    uiPrefs.compact = !!on;
    document.body.classList.toggle("compact", uiPrefs.compact);
    try { localStorage.setItem("chimera_compact", uiPrefs.compact ? "1" : "0"); } catch {}
      // âœ… rebuild UI immediately so play/edit mode switches live
  renderWarband();
  }
  function loadCompactPref() {
    try {
      const v = localStorage.getItem("chimera_compact");
      if (v === "1") uiPrefs.compact = true;
    } catch {}
  }

  function escapeHtml(str) {
    return String(str ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function getTextField(obj, keys) {
    for (const k of keys) {
      const v = obj?.[k];
      if (v !== undefined && v !== null && String(v).trim() !== "") return String(v);
    }
    return "";
  }

  // Data tables (loaded from JSON)
  let weapons = [];
  let accessories = [];
  let psychicPowers = [];
  let mutations = [];
  let meleeWeapons = [];
  let warbandTraits = [];
  let leaderTraits = [];

  // === Rules (hardwired for now, easy to change) ===
  const DEFENSE_TO_ACC_CAP = { 0: 0, 1: 1, 2: 2, 3: 3 };
  const SIDEARM_UNLOCK_SHOOT_TIER = 3;

  // === Stat costs + modifiers (hard-coded) ===
  const DEF_WILL_TABLE = {
    0: { mod: -2, cost: 0 },
    1: { mod: 0,  cost: 2 },
    2: { mod: 2,  cost: 4 },
    3: { mod: 4,  cost: 8 },
  };
  const SHOOT_FIGHT_TABLE = {
    0: { mod: -2, cost: 0 },
    1: { mod: -2, cost: 0 },
    2: { mod: 2,  cost: 3 },
    3: { mod: 4,  cost: 6 },
  };
  const SAVE_TARGET_BY_WILL = { 0: 14, 1: 14, 2: 13, 3: 11 };
  function clampMin(n, min) { return n < min ? min : n; }
  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

  function defenseMod(tier) { return (DEF_WILL_TABLE[tier] ?? DEF_WILL_TABLE[1]).mod; }
  function willMod(tier)    { return (DEF_WILL_TABLE[tier] ?? DEF_WILL_TABLE[1]).mod; }
  function shootMod(tier)   { return (SHOOT_FIGHT_TABLE[tier] ?? SHOOT_FIGHT_TABLE[1]).mod; }
  function fightMod(tier)   { return (SHOOT_FIGHT_TABLE[tier] ?? SHOOT_FIGHT_TABLE[1]).mod; }

  function statPointsCost(m) {
    const d = (DEF_WILL_TABLE[m.defense] ?? DEF_WILL_TABLE[1]).cost;
    const w = (DEF_WILL_TABLE[m.will] ?? DEF_WILL_TABLE[1]).cost;
    const s = (SHOOT_FIGHT_TABLE[m.shoot] ?? SHOOT_FIGHT_TABLE[1]).cost;
    const f = (SHOOT_FIGHT_TABLE[m.fight] ?? SHOOT_FIGHT_TABLE[1]).cost;
    return d + w + s + f;
  }

function woundsTotal(m) {
  const base =
    (m.defense ?? 0) + (m.shoot ?? 0) + (m.fight ?? 0) + (m.will ?? 0);
  return base + bonusWounds(m);
}

function armorClass(m) {
  return 10 + defenseMod(m.defense ?? 1) + acBonus(m);
}

  function equipmentCapacity(m) { return m.defense ?? 0; }
  function psychicMutationCapacity(m) { return m.will ?? 0; }
  function savingThrowTarget(m) { return clampMin((SAVE_TARGET_BY_WILL[m.will] ?? SAVE_TARGET_BY_WILL[1]), 10); }
//  function armorClass(m) { return 10 + defenseMod(m.defense ?? 1); }

  // NEW: ensure in-play state fields exist + stay clamped
  function ensurePlayState(m) {
    const maxW = woundsTotal(m);
    if (!Number.isFinite(Number(m.woundsCurrent))) m.woundsCurrent = maxW; // default to full
    m.woundsCurrent = clamp(Number(m.woundsCurrent), 0, maxW);

    if (!Number.isFinite(Number(m.horror))) m.horror = 0;
    m.horror = clamp(Number(m.horror), 0, 5);

    if (typeof m.hidden !== "boolean") m.hidden = false;
  }

  // Warband state: leader + 4 models
  const warband = {
    version: 4, // bumped because we added in-play fields
    name: "Unnamed Warband",
    pointCap: 75,
    warbandTraitIdx: "",
    leaderTraitIdx: "",
    members: [
      { role: "Leader", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 1", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 2", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 3", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 4", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
    ]
  };

  // Remember which collapsibles are open per member index
  const openPanelsByMember = new Map(); // memberIndex -> { accessories: true/false, psi: true/false }

  function memberWeaponPoints(m) {
    let sum = 0;

    if (m.weaponIdx !== "" && m.weaponIdx !== null && m.weaponIdx !== undefined) {
      const w = weapons[Number(m.weaponIdx)];
      sum += toIntOrNull(w?.points) ?? 0;
    }

    if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER &&
        m.sidearmIdx !== "" && m.sidearmIdx !== null && m.sidearmIdx !== undefined) {
      const s = weapons[Number(m.sidearmIdx)];
      sum += toIntOrNull(s?.points) ?? 0;
    }

    if (m.meleeIdx !== "" && m.meleeIdx !== null && m.meleeIdx !== undefined) {
      const mw = meleeWeapons[Number(m.meleeIdx)];
      sum += toIntOrNull(mw?.points) ?? 0;
    }

    return sum;
  }

  function memberAccessoryPoints(m) {
    let sum = 0;
    for (const idx of (m.accessoryIdx || [])) {
      const a = accessories[Number(idx)];
      sum += (toIntOrNull(a?.points) ?? 0);
    }
    return sum;
  }

  function memberPsiMutPoints(m) {
    let sum = 0;
    for (const idx of (m.psychicIdx || [])) {
      const p = psychicPowers[Number(idx)];
      sum += (toIntOrNull(p?.points) ?? 0);
    }
    for (const idx of (m.mutationIdx || [])) {
      const mu = mutations[Number(idx)];
      sum += (toIntOrNull(mu?.points) ?? 0);
    }
    return sum;
  }
function sumBonusesFromList(idxArr, lookup, fieldName) {
  let sum = 0;
  for (const idx of (idxArr || [])) {
    const obj = lookup[Number(idx)];
    const v = toIntOrNull(obj?.[fieldName]) ?? 0;
    sum += v;
  }
  return sum;
}

  function selectedAccessories(m) {
  return (m.accessoryIdx || []).map(i => accessories[Number(i)]).filter(Boolean);
}
function selectedMutations(m) {
  return (m.mutationIdx || []).map(i => mutations[Number(i)]).filter(Boolean);
}

// Pull a numeric AC bonus from either explicit fields OR text like "+1 AC", "AC +2", "Armor Class +1"
function acBonusFromObj(obj) {
  if (!obj) return 0;

  // 1) Prefer explicit numeric fields if you have them
  const direct =
    toIntOrNull(obj.ac_bonus) ??
    toIntOrNull(obj.armor_class_bonus) ??
    toIntOrNull(obj.acBonus) ??
    toIntOrNull(obj.AC) ??        // if you used AC as a bonus value (not recommended, but supported)
    toIntOrNull(obj.ac);          // if you used ac as a bonus value

  if (direct !== null) return direct;

  // 2) Fallback: parse effect text
  const txt = String(getTextField(obj, ["effect_text", "effect", "rule_text"]) || "");

  // matches: "+1 AC", "AC +1", "+2 Armor Class", "Armor Class -1"
  const m1 = txt.match(/([+-]\s*\d+)\s*(ac|armor\s*class)\b/i);
  if (m1) return parseInt(m1[1].replace(/\s+/g, ""), 10) || 0;

  const m2 = txt.match(/\b(ac|armor\s*class)\b\s*([+-]\s*\d+)/i);
  if (m2) return parseInt(m2[2].replace(/\s+/g, ""), 10) || 0;

  return 0;
}

function acBonus(m) {
  let sum = 0;

  // Accessories and mutations can affect AC (as you mentioned)
  for (const a of selectedAccessories(m)) sum += acBonusFromObj(a);
  for (const mu of selectedMutations(m)) sum += acBonusFromObj(mu);

  return sum;
}


function bonusAC(m) {
  const acc = sumBonusesFromList(m.accessoryIdx, accessories, "ac_bonus");
  const mut = sumBonusesFromList(m.mutationIdx, mutations, "ac_bonus");
  return acc + mut;
}

function bonusWounds(m) {
  const acc = sumBonusesFromList(m.accessoryIdx, accessories, "wounds_bonus");
  const mut = sumBonusesFromList(m.mutationIdx, mutations, "wounds_bonus");
  return acc + mut;
}

  function clearMemberLoadout(m) {
    m.weaponIdx = "";
    m.sidearmIdx = "";
    m.meleeIdx = "";
    m.accessoryIdx = [];
    m.psychicIdx = [];
    m.mutationIdx = [];
  }

  function memberTotalPoints(m) {
    return statPointsCost(m) + memberWeaponPoints(m) + memberAccessoryPoints(m) + memberPsiMutPoints(m);
  }

  function warbandTotalPoints() {
    return warband.members.reduce((acc, m) => acc + memberTotalPoints(m), 0);
  }

  function randomizeMemberLoadout(member, budget, opts = {}) {
  // opts: { allowNames: true/false }
  const allowNames = opts.allowNames !== false;

  // Start conservative so we can buy toys first
  member.defense = 1;
  member.shoot   = 1;
  member.fight   = 1;
  member.will    = 1;

  // Clear gear
  member.weaponIdx = "";
  member.sidearmIdx = "";
  member.meleeIdx = "";
  member.accessoryIdx = [];
  member.psychicIdx = [];
  member.mutationIdx = [];

  if (allowNames && (!member.name || !String(member.name).trim())) {
    member.name = randomModelName(member.role);
  }

  // Always keep play-state sane
  ensurePlayState(member);

  const remaining = () => budget - memberTotalPoints(member);

  // ---- Step 1: pick weapons first (fun core) ----
  // Choose a ranged weapon if we can afford one
  const rangedCandidates = weapons
    .map((w, idx) => ({ w, idx, pts: itemPoints(w) }))
    .filter(x => x.pts >= 0)
    .filter(x => x.pts <= remaining());

  if (rangedCandidates.length) {
    // Favor cheap-to-mid items so we can buy more stuff
    const sorted = rangedCandidates.sort((a, b) => a.pts - b.pts);
    const pool = sorted.slice(0, Math.min(sorted.length, 10)); // cheapest 10
    const choice = pick(pool);
    member.weaponIdx = String(choice.idx);
  }

  // Choose a melee weapon if affordable
  const meleeCandidates = meleeWeapons
    .map((w, idx) => ({ w, idx, pts: itemPoints(w) }))
    .filter(x => x.pts >= 0)
    .filter(x => x.pts <= remaining());

  if (meleeCandidates.length) {
    const sorted = meleeCandidates.sort((a, b) => a.pts - b.pts);
    const pool = sorted.slice(0, Math.min(sorted.length, 10));
    const choice = pick(pool);
    member.meleeIdx = String(choice.idx);
  }

  // ---- Step 2: buy accessories + powers/muts within capacity ----
  // Accessories capacity depends on defense tier, but weâ€™re still at tier 1 here -> small capacity.
  // We can still fill what we can afford within capacity.
  const tryAddAccessories = () => {
    const cap = DEFENSE_TO_ACC_CAP[member.defense] ?? 0;
    if (cap <= 0) return;

    const already = new Set((member.accessoryIdx || []).map(String));
    const candidates = accessories
      .map((a, idx) => ({ a, idx, pts: itemPoints(a) }))
      .filter(x => !already.has(String(x.idx)))
      .filter(x => x.pts <= remaining());

    // 0..cap items
    const want = randInt(0, cap);
    for (const c of shuffle(candidates)) {
      if ((member.accessoryIdx || []).length >= want) break;
      if (c.pts <= remaining()) {
        member.accessoryIdx.push(Number(c.idx));
      }
    }
  };

  const tryAddPsiMut = () => {
    const cap = psychicMutationCapacity(member);
    if (cap <= 0) return;

    const used = () => (member.psychicIdx?.length || 0) + (member.mutationIdx?.length || 0);
    const slotsLeft = () => cap - used();
    if (slotsLeft() <= 0) return;

    // Blend psychic + mutations into one candidate list
    const psiCandidates = psychicPowers.map((p, idx) => ({ kind: "psi", obj: p, idx, pts: itemPoints(p) }));
    const mutCandidates = mutations.map((mu, idx) => ({ kind: "mut", obj: mu, idx, pts: itemPoints(mu) }));

    const alreadyPsi = new Set((member.psychicIdx || []).map(String));
    const alreadyMut = new Set((member.mutationIdx || []).map(String));

    const candidates = psiCandidates.concat(mutCandidates)
      .filter(x => x.kind === "psi" ? !alreadyPsi.has(String(x.idx)) : !alreadyMut.has(String(x.idx)))
      .filter(x => x.pts <= remaining());

    // 0..cap picks
    const want = randInt(0, cap);
    for (const c of shuffle(candidates)) {
      if (used() >= want) break;
      if (slotsLeft() <= 0) break;
      if (c.pts <= remaining()) {
        if (c.kind === "psi") member.psychicIdx.push(Number(c.idx));
        else member.mutationIdx.push(Number(c.idx));
      }
    }
  };

  // First pass at tier 1 capacity
  tryAddAccessories();
  tryAddPsiMut();

  // ---- Step 3: only now upgrade tiers with leftover points ----
  // Weâ€™ll do small upgrades, and after each upgrade we try to buy more toys.
  // This keeps the â€œfun stuffâ€ prioritized.
  const upgradeOptions = [
    { key: "defense", to: 2 }, { key: "shoot", to: 2 }, { key: "fight", to: 2 }, { key: "will", to: 2 },
    { key: "defense", to: 3 }, { key: "shoot", to: 3 }, { key: "fight", to: 3 }, { key: "will", to: 3 },
  ];

  // weighted order: more likely to do 2s than 3s
  const upgradeBag = [
    ...upgradeOptions.filter(x => x.to === 2),
    ...upgradeOptions.filter(x => x.to === 2),
    ...upgradeOptions.filter(x => x.to === 2),
    ...upgradeOptions.filter(x => x.to === 3),
  ];

  let safety = 30;
  while (safety-- > 0) {
    if (remaining() <= 0) break;

    const u = pick(upgradeBag);
    if ((member[u.key] ?? 1) >= u.to) continue;

    const before = memberTotalPoints(member);
    member[u.key] = u.to;
    ensurePlayState(member);

    const after = memberTotalPoints(member);
    const delta = after - before;

    if (delta <= remaining() + delta) {
      // ok, we can afford it (remaining() already accounts for new points)
      // if we upgraded shoot to 3, consider sidearm too
      if (u.key === "shoot" && member.shoot >= SIDEARM_UNLOCK_SHOOT_TIER) {
        const sideCandidates = weapons
          .map((w, idx) => ({ w, idx, pts: itemPoints(w) }))
          .filter(x =>
            String(x.w.name ?? "").toLowerCase().includes("sidearm") ||
            String(x.w.name ?? "").toLowerCase().includes("pistol")
          )
          .filter(x => x.pts <= remaining());

        if (sideCandidates.length) {
          const sorted = sideCandidates.sort((a, b) => a.pts - b.pts);
          const pool = sorted.slice(0, Math.min(sorted.length, 10));
          member.sidearmIdx = String(pick(pool).idx);
        }
      }

      // Upgrading defense/will increases capacities: try to fill new slots
      tryAddAccessories();
      tryAddPsiMut();
    } else {
      // revert if it somehow busted budget (belt+suspenders)
      member[u.key] = 1;
      ensurePlayState(member);
      break;
    }
  }

  // Final clamp
  ensurePlayState(member);
}


  function randomizeWarband() {
  // Name warband + any unnamed models
  warband.name = randomWarbandName();
  if (els.warbandName) els.warbandName.value = warband.name;

  // Budget strategy: spend most of cap, but leave a tiny buffer so we donâ€™t constantly overflow
  const cap = toIntOrNull(els.pointCap.value) ?? warband.pointCap ?? 75;
  warband.pointCap = cap;

  // Give each model a â€œsoft budgetâ€ so gear gets spread around.
  // Leader gets a little more.
  const base = Math.floor(cap / warband.members.length);
  const budgets = warband.members.map((m, i) => base + (i === 0 ? 6 : 0));

  // Randomize each member under their budget
  warband.members.forEach((m, i) => {
    // keep role, randomize name and kit
    m.name = randomModelName(m.role);
    randomizeMemberLoadout(m, budgets[i], { allowNames: true });
  });

  // If total is still under cap by a lot, sprinkle extra upgrades (gear-first is already done)
  // Weâ€™ll just let the normal render show â€œwithin capâ€ rather than forcing exact spend.
  renderWarband();
}


  function makeCollapsible(titleText, initiallyOpen = false, onToggle = null) {
    const wrap = document.createElement("div");
    wrap.style.marginTop = "12px";
    wrap.style.border = "1px solid #eee";
    wrap.style.borderRadius = "10px";
    wrap.style.overflow = "hidden";

    const header = document.createElement("button");
    header.type = "button";
    header.style.width = "100%";
    header.style.textAlign = "left";
    header.style.padding = "10px 12px";
    header.style.border = "0";
    header.style.background = "#f7f7f7";
    header.style.cursor = "pointer";
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    header.style.fontWeight = "800";

    const title = document.createElement("span");
    title.textContent = titleText;

    const chevron = document.createElement("span");
    chevron.textContent = initiallyOpen ? "â–¾" : "â–¸";
    chevron.style.opacity = "0.8";

    header.appendChild(title);
    header.appendChild(chevron);

    const body = document.createElement("div");
    body.style.padding = "10px 12px";
    body.style.display = initiallyOpen ? "block" : "none";
    body.style.background = "#fff";

    function setOpen(open) {
      body.style.display = open ? "block" : "none";
      chevron.textContent = open ? "â–¾" : "â–¸";
      if (typeof onToggle === "function") onToggle(open);
    }

    header.addEventListener("click", () => {
      const open = body.style.display === "none";
      setOpen(open);
    });

    wrap.appendChild(header);
    wrap.appendChild(body);

    return { wrap, body, setOpen };
  }

  function setIoVisible(vis, title) {
    els.ioArea.style.display = vis ? "block" : "none";
    if (title) els.ioTitle.textContent = title;
    els.ioMsg.textContent = "";
  }

  function traitDescription(obj) {
    const txt = obj?.effect_text ?? obj?.effect ?? obj?.rule_text ?? "";
    return String(txt ?? "").trim();
  }

  function renderTraitDescriptions() {
    if (els.warbandTraitDesc) {
      if (warband.warbandTraitIdx === "") els.warbandTraitDesc.textContent = "";
      else els.warbandTraitDesc.textContent = traitDescription(warbandTraits[Number(warband.warbandTraitIdx)]) || "â€”";
    }
    if (els.leaderTraitDesc) {
      if (warband.leaderTraitIdx === "") els.leaderTraitDesc.textContent = "";
      else els.leaderTraitDesc.textContent = traitDescription(leaderTraits[Number(warband.leaderTraitIdx)]) || "â€”";
    }
  }

  function makeSelectedWeaponsSummary(m) {
    const box = document.createElement("div");
    box.style.marginTop = "10px";
    box.style.padding = "10px 12px";
    box.style.border = "1px solid #eee";
    box.style.borderRadius = "10px";
    box.style.background = "#fafafa";
    box.style.fontSize = "13px";

    const head = document.createElement("div");
    head.style.fontWeight = "900";
    head.textContent = "Selected Weapons";
    box.appendChild(head);

    function weaponLine(label, w) {
      const row = document.createElement("div");
      row.style.marginTop = "8px";
      row.style.whiteSpace = "pre-wrap";

      if (!w) {
        row.textContent = `${label}: â€”`;
        row.style.color = "#666";
        return row;
      }

      const name = w.name ?? "(Unnamed)";
      const pts = toIntOrNull(w.points) ?? 0;

      const actions = (w.max_actions !== undefined && String(w.max_actions).trim() !== "") ? `A:${w.max_actions}` : "";
      const dmg = (w.damage !== undefined && String(w.damage).trim() !== "") ? `D:${w.damage}` : "";
      const ap = (w.ap !== undefined && String(w.ap).trim() !== "") ? `AP:${w.ap}` : "";

      const statBits = [actions, dmg, ap].filter(Boolean).join(" Â· ");
      const eff = getTextField(w, ["effect_text", "effect", "rule_text"]);

      row.textContent =
        `${label}: ${name} (${pts} pts)` +
        (statBits ? ` â€” ${statBits}` : "") +
        (eff ? ` â€” ${eff}` : "");

      return row;
    }

    const ranged = (m.weaponIdx === "" ? null : weapons[Number(m.weaponIdx)]);
    const sidearm =
      ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER && m.sidearmIdx !== "")
        ? weapons[Number(m.sidearmIdx)]
        : null;
    const melee = (m.meleeIdx === "" ? null : meleeWeapons[Number(m.meleeIdx)]);

    box.appendChild(weaponLine("Ranged", ranged));
    if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER) box.appendChild(weaponLine("Sidearm", sidearm));
    box.appendChild(weaponLine("Melee", melee));

    return box;
  }

  function makeSelectedAccessoriesSummary(m) {
    const box = document.createElement("div");
    box.style.marginTop = "10px";
    box.style.padding = "10px 12px";
    box.style.border = "1px solid #eee";
    box.style.borderRadius = "10px";
    box.style.background = "#fafafa";
    box.style.fontSize = "13px";

    const head = document.createElement("div");
    head.style.fontWeight = "900";
    head.textContent = "Selected Accessories";
    box.appendChild(head);

    const chosen = (m.accessoryIdx || [])
      .map(i => accessories[Number(i)])
      .filter(Boolean);

    if (!chosen.length) {
      const none = document.createElement("div");
      none.style.marginTop = "8px";
      none.style.color = "#666";
      none.textContent = "â€”";
      box.appendChild(none);
      return box;
    }

    chosen.forEach(a => {
      const row = document.createElement("div");
      row.style.marginTop = "8px";
      row.style.whiteSpace = "pre-wrap";

      const name = a.name ?? "(Unnamed)";
      const pts = toIntOrNull(a.points) ?? 0;
      const eff = getTextField(a, ["effect_text", "effect", "rule_text"]);

      row.textContent = `${name} (${pts} pts)` + (eff ? ` â€” ${eff}` : "");
      box.appendChild(row);
    });

    return box;
  }

  // NEW: headline shows current wounds + horror
function makeStatsHeadline(m) {
  ensurePlayState(m);
  const isCompact = document.body.classList.contains("compact");

  const safeName = (x) =>
    (x && (x.name ?? x.title ?? x.label)) ? String(x.name ?? x.title ?? x.label) : "";

    const safeText = (v) => String(v ?? "").trim();

const getNote = (obj) => {
  const note = safeText(getTextField(obj, ["effect_text", "effect", "rule_text"]));
  return note; // no truncation
};


const itemLine = (obj) => {
  if (!obj) return "â€”";
  const nm = safeName(obj) || "â€”";

  // Weapon-ish stats (only show if present)
  const a = safeText(obj.max_actions);
  const d = safeText(obj.damage);
  const ap = safeText(obj.ap);

  const statBits = [
    a ? `A:${a}` : "",
    d ? `D:${d}` : "",
    ap ? `AP:${ap}` : ""
  ].filter(Boolean).join(" ");

  const note = getNote(obj);

  // Put stats before note so it reads like: "Rifle (A:2 D:1 AP:0) â€” blah"
  const core = statBits ? `${nm} (${statBits})` : nm;
  return note ? `${core} â€” ${note}` : core;
};


  const joinItemLines = (idxArr, lookup) => {
    const items = (idxArr || [])
      .map((idx) => lookup[Number(idx)])
      .filter(Boolean)
      .map(itemLine);

    // In compact mode, newlines are nice since you already allow wrapping
    return items.length ? items.map(x => `â€¢ ${x}`).join("\n") : "â€”";
  };


  const joinNames = (arr, lookup) =>
    (arr || []).map((idx) => safeName(lookup[Number(idx)])).filter(Boolean).join(", ");

  // Weapons: Ranged / Melee / (Pistol if unlocked)
  const rangedObj =
    (m.weaponIdx !== "" && m.weaponIdx != null) ? weapons[Number(m.weaponIdx)] : null;

  const meleeObj =
    (m.meleeIdx !== "" && m.meleeIdx != null) ? meleeWeapons[Number(m.meleeIdx)] : null;

  const sidearmUnlocked = (m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER;

  const pistolObj =
    (sidearmUnlocked && m.sidearmIdx !== "" && m.sidearmIdx != null)
      ? weapons[Number(m.sidearmIdx)]
      : null;

  const weaponsText =
    `R: ${itemLine(rangedObj)}\n` +
    `M: ${itemLine(meleeObj)}` +
    (sidearmUnlocked ? `\nP: ${itemLine(pistolObj)}` : "");


  const accText = joinItemLines(m.accessoryIdx, accessories);
  const psiText = joinItemLines(m.psychicIdx, psychicPowers);
  const mutText = joinItemLines(m.mutationIdx, mutations);

  const psiMutText = (() => {
    const psiHas = psiText && psiText !== "â€”";
    const mutHas = mutText && mutText !== "â€”";
    if (psiHas && mutHas) return `Psychic:\n${psiText}\n\nMut:\n${mutText}`;
    if (psiHas) return `Psychic:\n${psiText}`;
    if (mutHas) return `Mut:\n${mutText}`;
    return "â€”";
  })();


  const ac = armorClass(m);
  const saveT = savingThrowTarget(m);
  const maxW = woundsTotal(m);

  const dMod = defenseMod(m.defense ?? 1);
  const sMod = shootMod(m.shoot ?? 1);
  const fMod = fightMod(m.fight ?? 1);
  const wMod = willMod(m.will ?? 1);

  const fmtSigned = (n) => {
    const v = Number(n) || 0;
    return v >= 0 ? `+${v}` : `${v}`;
  };

  // Non-compact: return nothing (you wanted this hidden in edit mode)
  if (!isCompact) return document.createElement("div");

  // Compact: grid
  const wrap = document.createElement("div");
  wrap.className = "compactHeadline";

  const addKV = (k, v, wrapValue = false) => {
    const kv = document.createElement("div");
    kv.className = "kv";

    const kk = document.createElement("span");
    kk.className = "k";
    kk.textContent = k;

    const vv = document.createElement("span");
    vv.className = "v" + (wrapValue ? " wrap" : "");
    vv.textContent = v;

    kv.appendChild(kk);
    kv.appendChild(vv);
    wrap.appendChild(kv);
  };

  addKV("Weapons", weaponsText, true);
  addKV("Accessories", accText, true);
  addKV("Powers / Mut", psiMutText, true);
  addKV("AC / Save", `AC ${ac} â€¢ Save ${saveT}`);
  addKV("Mods", `D${fmtSigned(dMod)} S${fmtSigned(sMod)} F${fmtSigned(fMod)} W${fmtSigned(wMod)}`);

  return wrap;
}




  // NEW: show/hide list above grid
  function renderModelVisibilityControls() {
    if (!els.modelVisibility || !els.modelVisibilityGrid) return;

    els.modelVisibilityGrid.innerHTML = "";
    els.modelVisibility.style.display = "block";

    warband.members.forEach((m, i) => {
      ensurePlayState(m);
      const id = `show_m_${i}`;
      const label = document.createElement("label");

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.id = id;
      cb.checked = !m.hidden;

      cb.addEventListener("change", () => {
        m.hidden = !cb.checked;
        renderWarband();
      });

      const name = (m.name && String(m.name).trim()) ? ` â€” ${m.name}` : "";
      const txt = document.createElement("span");
      txt.textContent = `${m.role}${name}`;

      label.appendChild(cb);
      label.appendChild(txt);
      els.modelVisibilityGrid.appendChild(label);
    });
  }

  // NEW: in-play +/- control factory
function makeCounter(labelText, getText, onMinus, onPlus, extraBtnText, onExtra) {
  const row = document.createElement("div");
  row.className = "playrow";

  const l = document.createElement("div");
  l.style.fontWeight = "900";
  l.style.color = "#333";
  l.textContent = labelText;

  const c = document.createElement("div");
  c.className = "counter";

  const minus = document.createElement("button");
  minus.type = "button";
  minus.className = "ctrBtn";
  minus.textContent = "âˆ’";
  minus.addEventListener("click", onMinus);

  const val = document.createElement("div");
  val.className = "val";
  val.textContent = getText();

  const plus = document.createElement("button");
  plus.type = "button";
  plus.className = "ctrBtn";
  plus.textContent = "+";
  plus.addEventListener("click", onPlus);

  c.appendChild(minus);
  c.appendChild(val);
  c.appendChild(plus);

  // âœ… Put Full/Clear INSIDE the pill as the right-most segment
  if (extraBtnText && typeof onExtra === "function") {
    const extra = document.createElement("button");
    extra.type = "button";
    extra.className = "ctrExtra";
    extra.textContent = extraBtnText;
    extra.addEventListener("click", onExtra);
    c.appendChild(extra);
  }

  row.appendChild(l);
  row.appendChild(c);

  return { row, setValueText: (t) => (val.textContent = t) };
}



  const STORAGE_KEY = "chimera_warband_v4";

function saveWarbandToStorage() {
  try {
    // make sure derived/in-play fields are sane before saving
    warband.members.forEach(ensurePlayState);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(warband));
  } catch (e) {
    // ignore storage errors (private mode/quota)
  }
}

function loadWarbandFromStorage() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;

    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || !Array.isArray(parsed.members)) return false;

    // reuse your existing import logic by injecting into warband cleanly:
    warband.version = parsed.version ?? warband.version;
    warband.pointCap = toIntOrNull(parsed.pointCap) ?? warband.pointCap;
    warband.name = String(parsed.name ?? warband.name ?? "");
    warband.warbandTraitIdx = (parsed.warbandTraitIdx == null || parsed.warbandTraitIdx === "") ? "" : String(parsed.warbandTraitIdx);
    warband.leaderTraitIdx  = (parsed.leaderTraitIdx  == null || parsed.leaderTraitIdx  === "") ? "" : String(parsed.leaderTraitIdx);

    const incoming = parsed.members.slice(0, warband.members.length);

    warband.members = warband.members.map((def, i) => {
      const inc = incoming[i] ?? {};
      const merged = {
        ...def,
        name: String(inc.name ?? def.name ?? ""),
        defense: toIntOrNull(inc.defense) ?? def.defense,
        shoot:   toIntOrNull(inc.shoot)   ?? def.shoot,
        fight:   toIntOrNull(inc.fight)   ?? def.fight,
        will:    toIntOrNull(inc.will)    ?? def.will,

        weaponIdx: (inc.weaponIdx == null || inc.weaponIdx === "") ? "" : String(inc.weaponIdx),
        sidearmIdx:(inc.sidearmIdx== null || inc.sidearmIdx=== "") ? "" : String(inc.sidearmIdx),
        meleeIdx:  (inc.meleeIdx  == null || inc.meleeIdx  === "") ? "" : String(inc.meleeIdx),

        accessoryIdx: Array.isArray(inc.accessoryIdx) ? inc.accessoryIdx.map(Number).filter(Number.isFinite) : [],
        psychicIdx:   Array.isArray(inc.psychicIdx)   ? inc.psychicIdx.map(Number).filter(Number.isFinite)   : [],
        mutationIdx:  Array.isArray(inc.mutationIdx)  ? inc.mutationIdx.map(Number).filter(Number.isFinite)  : [],

        woundsCurrent: toIntOrNull(inc.woundsCurrent),
        horror: toIntOrNull(inc.horror) ?? 0,
        hidden: (typeof inc.hidden === "boolean") ? inc.hidden : false,
      };
      ensurePlayState(merged);
      return merged;
    });

    return true;
  } catch {
    return false;
  }
}


  function renderWarband() {
    warband.pointCap = toIntOrNull(els.pointCap.value) ?? 0;

    // NEW: draw show/hide controls
    renderModelVisibilityControls();

    els.warbandGrid.innerHTML = "";
    const collapseModelsOnPhone =
  document.body.classList.contains("compact") &&
  window.matchMedia("(max-width: 480px)").matches;


    warband.members.forEach((m, memberIndex) => {
      ensurePlayState(m);

      // If hidden, still keep state, just don't render card
      if (m.hidden) return;

      const card = document.createElement("div");
      card.style.border = "1px solid #ddd";
      card.style.borderRadius = "10px";
      card.style.padding = "14px";

      // Header
      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.justifyContent = "space-between";
      header.style.alignItems = "baseline";
      header.style.gap = "10px";

      const title = document.createElement("div");
      title.style.display = "flex";
      title.style.flexDirection = "column";
      title.style.gap = "6px";

      const roleLine = document.createElement("div");
      roleLine.style.fontWeight = "900";
      roleLine.style.fontSize = "16px";
      roleLine.textContent = m.role;

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.placeholder = `${m.role} name`;
      nameInput.value = m.name ?? "";
      nameInput.style.width = "100%";
      nameInput.addEventListener("input", () => {
        m.name = nameInput.value;
        // update show/hide labels without re-rendering everything
        renderModelVisibilityControls();
      });

      title.appendChild(roleLine);
      title.appendChild(nameInput);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";
      right.style.gap = "10px";

      const pts = document.createElement("div");
      pts.style.fontWeight = "800";
      pts.textContent = `${memberTotalPoints(m)} pts`;

      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.textContent = "Clear Loadout";
      clearBtn.style.padding = "6px 10px";
      clearBtn.style.borderRadius = "10px";
      clearBtn.style.border = "1px solid #ddd";
      clearBtn.style.background = "#fff";
      clearBtn.style.cursor = "pointer";
      clearBtn.addEventListener("click", () => {
        clearMemberLoadout(m);
        renderWarband();
      });

      right.appendChild(pts);
      right.appendChild(clearBtn);

      const randomBtn = document.createElement("button");
randomBtn.type = "button";
randomBtn.textContent = "ðŸŽ² Random Loadout";
randomBtn.style.padding = "6px 10px";
randomBtn.style.borderRadius = "10px";
randomBtn.style.border = "1px solid #ddd";
randomBtn.style.background = "#fff";
randomBtn.style.cursor = "pointer";

randomBtn.addEventListener("click", () => {
  // Give this model a reasonable slice of the overall cap.
  // Slightly more for Leader.
  const cap = toIntOrNull(els.pointCap.value) ?? warband.pointCap ?? 75;
  const slice = Math.floor(cap / warband.members.length) + (memberIndex === 0 ? 6 : 0);

  randomizeMemberLoadout(m, slice, { allowNames: true });
  renderWarband();
});

right.appendChild(randomBtn);


      header.appendChild(title);
      header.appendChild(right);
      
      // In phone-compact view, wrap the whole model UI in a collapsible
let outer = card;
let contentHost = card;

if (collapseModelsOnPhone) {
  // Title shown when collapsed (keep it short)
  const nm = (m.name && String(m.name).trim()) ? ` â€” ${m.name.trim()}` : "";
  const titleText = `${m.role}${nm} (${memberTotalPoints(m)} pts)`;

  // Open Leader by default, others closed
  const col = makeCollapsible(titleText, memberIndex === 0);

  // Make the collapsible body feel like the old card (padding, etc.)
  col.body.style.padding = "12px";
  col.body.style.background = "#fff";

  // Put original card content into collapsible body instead of the grid
  outer = col.wrap;
  contentHost = col.body;
}
contentHost.appendChild(header);


      // Tier select helper (shows Tier + mod)
      function tierSelect(label, key) {
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.flexDirection = "column";
        wrap.style.gap = "8px";
        wrap.style.alignItems = "center";

        const l = document.createElement("div");
        l.innerHTML = `<strong>${escapeHtml(label)}</strong>`;

        const s = document.createElement("select");
        s.style.width = "100%";
        const tiers = [1, 2, 3];
        const table =
          (key === "defense" || key === "will") ? DEF_WILL_TABLE :
          (key === "shoot" || key === "fight") ? SHOOT_FIGHT_TABLE :
          null;

        s.innerHTML = tiers.map(t => {
          const entry = table?.[t];
          const mod = entry?.mod ?? 0;
          const modStr = mod >= 0 ? `+${mod}` : `${mod}`;
          return `<option value="${t}">T${t} (${modStr})</option>`;
        }).join("");

        s.value = String(m[key] ?? 0);

        s.addEventListener("change", () => {
          m[key] = Number(s.value);
          if (key === "shoot" && (m.shoot ?? 0) < SIDEARM_UNLOCK_SHOOT_TIER) m.sidearmIdx = "";

          // NEW: re-clamp current wounds when max wounds change
          ensurePlayState(m);

          renderWarband();
        });

        wrap.appendChild(l);
        wrap.appendChild(s);
        return wrap;
      }

      // Stats block
      const statsBlock = document.createElement("div");
      statsBlock.style.marginTop = "10px";
      statsBlock.style.display = "grid";
      statsBlock.style.gridTemplateColumns = "repeat(auto-fit, minmax(240px, 1fr))";
      statsBlock.style.gap = "10px";
      
const isPlayMode = document.body.classList.contains("compact");

if (!isPlayMode) {
  statsBlock.appendChild(tierSelect("Defense", "defense"));
  statsBlock.appendChild(tierSelect("Shoot", "shoot"));
  statsBlock.appendChild(tierSelect("Fight", "fight"));
  statsBlock.appendChild(tierSelect("Willpower", "will"));
  contentHost.appendChild(statsBlock);
}

// Headline stats row (Play Mode only)
if (isPlayMode) {
  contentHost.appendChild(makeStatsHeadline(m));
}



      // NEW: In-play controls (Wounds +/- and Horror 0â€“5)
      const play = document.createElement("div");
      play.className = "playbar";

      const maxW = woundsTotal(m);

      const woundsCtl = makeCounter(
        "Wounds",
        () => `${m.woundsCurrent}/${maxW}`,
        () => { m.woundsCurrent = clamp(m.woundsCurrent - 1, 0, maxW); renderWarband(); },
        () => { m.woundsCurrent = clamp(m.woundsCurrent + 1, 0, maxW); renderWarband(); },
        "Full",
        () => { m.woundsCurrent = maxW; renderWarband(); }
      );

      const horrorCtl = makeCounter(
        "Horror",
        () => `${m.horror}/5`,
        () => { m.horror = clamp(m.horror - 1, 0, 5); renderWarband(); },
        () => { m.horror = clamp(m.horror + 1, 0, 5); renderWarband(); },
        "Clear",
        () => { m.horror = 0; renderWarband(); }
      );

      play.appendChild(woundsCtl.row);
      play.appendChild(horrorCtl.row);

// âœ… Regular mode: show AC/Save above the Wounds tracker
if (!isPlayMode) {
  const quick = document.createElement("div");
  quick.style.marginTop = "10px";
  quick.style.padding = "8px 10px";
  quick.style.border = "1px solid #eee";
  quick.style.borderRadius = "10px";
  quick.style.background = "#fafafa";
  quick.style.fontSize = "13px";
  quick.style.fontWeight = "800";
  quick.textContent = `AC ${armorClass(m)} â€¢ Save ${savingThrowTarget(m)}`;
  contentHost.appendChild(quick);
}
      
      contentHost.appendChild(play);

      // Derived stats (collapsible)
      const statsSection = makeCollapsible("Stats", false);
      const derived = statsSection.body;

      derived.style.padding = "10px 12px";
      derived.style.background = "#fafafa";

      const statLine = (label, value) => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.justifyContent = "space-between";
        row.style.gap = "12px";
        row.style.marginTop = "6px";
        row.innerHTML = `<span style="color:#444;">${escapeHtml(label)}</span><span style="font-weight:800;">${escapeHtml(value)}</span>`;
        return row;
      };

    //  derived.appendChild(statLine("Armor Class (AC)", String(armorClass(m))));

      const acB = acBonus(m);
derived.appendChild(
  statLine("Armor Class (AC)", acB ? `${armorClass(m)} (includes +${acB})` : String(armorClass(m)))
);

      derived.appendChild(statLine("Saving Throw Target", String(savingThrowTarget(m))));
      derived.appendChild(statLine("Wounds (Max)", String(woundsTotal(m))));
      derived.appendChild(statLine("Accessory Slots", `${(m.accessoryIdx || []).length}/${equipmentCapacity(m)}`));
      derived.appendChild(statLine("Psi/Mut Slots", `${((m.psychicIdx || []).length + (m.mutationIdx || []).length)}/${psychicMutationCapacity(m)}`));
      derived.appendChild(statLine("Defense Mod", String(defenseMod(m.defense ?? 1))));
      derived.appendChild(statLine("Shoot Mod", String(shootMod(m.shoot ?? 1))));
      derived.appendChild(statLine("Fight Mod", String(fightMod(m.fight ?? 1))));
      derived.appendChild(statLine("Willpower Mod", String(willMod(m.will ?? 1))));
      derived.appendChild(statLine("Stat Points", String(statPointsCost(m))));
      derived.appendChild(statLine("Gear Points", String(memberWeaponPoints(m) + memberAccessoryPoints(m) + memberPsiMutPoints(m))));
      derived.appendChild(statLine("Model Total Points", String(memberTotalPoints(m))));
      contentHost.appendChild(statsSection.wrap);
      
if (!isPlayMode) {
      // Ranged Weapon
      const weaponRow = document.createElement("div");
      weaponRow.style.marginTop = "12px";
      weaponRow.innerHTML = "<strong>Ranged Weapon</strong>";

      const sel = document.createElement("select");
      sel.style.width = "100%";
      sel.style.marginTop = "6px";
      sel.innerHTML =
        `<option value="">â€” None â€”</option>` +
        weapons.map((w, idx) => {
          const p = toIntOrNull(w.points) ?? 0;
          const nm = escapeHtml(w.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm} (${p} pts)</option>`;
        }).join("");

      sel.value = m.weaponIdx === "" ? "" : String(m.weaponIdx);
      sel.addEventListener("change", () => {
        m.weaponIdx = sel.value === "" ? "" : sel.value;
        renderWarband();
      });

      weaponRow.appendChild(sel);
      contentHost.appendChild(weaponRow);

      // Sidearm (Shoot >= 3)
      if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER) {
        const sidearmRow = document.createElement("div");
        sidearmRow.style.marginTop = "10px";
        sidearmRow.innerHTML = "<strong>Sidearm (Shoot Tier 3+)</strong>";

        const sidearms = weapons
          .map((w, idx) => ({ w, idx }))
          .filter(x =>
            String(x.w.name ?? "").toLowerCase().includes("sidearm") ||
            String(x.w.name ?? "").toLowerCase().includes("pistol")
          );

        const sideSel = document.createElement("select");
        sideSel.style.width = "100%";
        sideSel.style.marginTop = "6px";
        sideSel.innerHTML =
          `<option value="">â€” None â€”</option>` +
          sidearms.map(x => {
            const p = toIntOrNull(x.w.points) ?? 0;
            const nm = escapeHtml(x.w.name ?? "(Unnamed)");
            return `<option value="${x.idx}">${nm} (${p} pts)</option>`;
          }).join("");

        sideSel.value = m.sidearmIdx === "" ? "" : String(m.sidearmIdx);
        sideSel.addEventListener("change", () => {
          m.sidearmIdx = sideSel.value === "" ? "" : sideSel.value;
          renderWarband();
        });

        sidearmRow.appendChild(sideSel);
        contentHost.appendChild(sidearmRow);
      }

      // Melee weapon
      const meleeSection = document.createElement("div");
      meleeSection.style.marginTop = "12px";
      meleeSection.innerHTML = "<strong>Melee Weapon</strong>";

      const meleeSel = document.createElement("select");
      meleeSel.style.width = "100%";
      meleeSel.style.marginTop = "6px";
      meleeSel.innerHTML =
        `<option value="">â€” None â€”</option>` +
        meleeWeapons.map((w, idx) => {
          const p = toIntOrNull(w.points) ?? 0;
          const nm = escapeHtml(w.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm} (${p} pts)</option>`;
        }).join("");

      meleeSel.value = m.meleeIdx === "" ? "" : String(m.meleeIdx);
      meleeSel.addEventListener("change", () => {
        m.meleeIdx = meleeSel.value === "" ? "" : meleeSel.value;
        renderWarband();
      });

      meleeSection.appendChild(meleeSel);
      contentHost.appendChild(meleeSection);
      contentHost.appendChild(makeSelectedWeaponsSummary(m));
}


      const openState = openPanelsByMember.get(memberIndex) || { accessories: false, psi: false };
if (!isPlayMode) {
      // Accessories
      const accSection = makeCollapsible("Edit Accessories", openState.accessories, (isOpen) => {
        const s = openPanelsByMember.get(memberIndex) || { accessories: false, psi: false };
        s.accessories = isOpen;
        openPanelsByMember.set(memberIndex, s);
      });
      const accWrap = accSection.body;

      const accCap = DEFENSE_TO_ACC_CAP[m.defense] ?? 0;
      const accUsed = (m.accessoryIdx || []).length;

      const capLine = document.createElement("div");
      capLine.style.marginTop = "6px";
      capLine.innerHTML = accUsed > accCap
        ? `<span style="color:#8a1f11; font-weight:700;">Over capacity: ${accUsed}/${accCap}</span>`
        : `<span style="color:#444;">Capacity: ${accUsed}/${accCap}</span>`;
      accWrap.appendChild(capLine);

      const list = document.createElement("div");
      list.style.marginTop = "6px";

      const selected = new Set((m.accessoryIdx || []).map(String));
      accessories.forEach((a, idx) => {
        const p = toIntOrNull(a.points) ?? 0;
        const name = a.name ?? "(Unnamed)";
        const id = `m${memberIndex}_a${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = selected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.accessoryIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.accessoryIdx = [...s].map(Number);
          ensurePlayState(m);
          renderWarband();
        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${p} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        list.appendChild(line);
      });

      accWrap.appendChild(list);
      contentHost.appendChild(accSection.wrap);
      contentHost.appendChild(makeSelectedAccessoriesSummary(m));
}
      if (!isPlayMode) {

      // Psychic Powers + Mutations
      const psiSection = makeCollapsible("Edit Psychic / Mutations", openState.psi, (isOpen) => {
        const s = openPanelsByMember.get(memberIndex) || { accessories: false, psi: false };
        s.psi = isOpen;
        openPanelsByMember.set(memberIndex, s);
      });
      const psiWrap = psiSection.body;

      const pmCap = psychicMutationCapacity(m);
      const pmUsed = (m.psychicIdx || []).length + (m.mutationIdx || []).length;

      const pmLine = document.createElement("div");
      pmLine.style.marginTop = "6px";
      pmLine.innerHTML = pmUsed > pmCap
        ? `<span style="color:#8a1f11; font-weight:700;">Over capacity: ${pmUsed}/${pmCap}</span>`
        : `<span style="color:#444;">Capacity: ${pmUsed}/${pmCap}</span>`;
      psiWrap.appendChild(pmLine);

      // Psychic list
      const psyTitle = document.createElement("div");
      psyTitle.style.marginTop = "8px";
      psyTitle.innerHTML = "<strong style='font-size:13px;'>Psychic Powers</strong>";
      psiWrap.appendChild(psyTitle);

      const psyList = document.createElement("div");
      psyList.style.marginTop = "6px";

      const psySelected = new Set((m.psychicIdx || []).map(String));
      psychicPowers.forEach((p, idx) => {
        const pts = toIntOrNull(p.points) ?? 0;
        const name = p.name ?? "(Unnamed)";
        const id = `m${memberIndex}_psy${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = psySelected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.psychicIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.psychicIdx = [...s].map(Number);
          renderWarband();
        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${pts} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        psyList.appendChild(line);
      });
      psiWrap.appendChild(psyList);

      // Mutations list
      const mutTitle = document.createElement("div");
      mutTitle.style.marginTop = "10px";
      mutTitle.innerHTML = "<strong style='font-size:13px;'>Mutations</strong>";
      psiWrap.appendChild(mutTitle);

      const mutList = document.createElement("div");
      mutList.style.marginTop = "6px";

      const mutSelected = new Set((m.mutationIdx || []).map(String));
      mutations.forEach((mu, idx) => {
        const pts = toIntOrNull(mu.points) ?? 0;
        const name = mu.name ?? "(Unnamed)";
        const id = `m${memberIndex}_mut${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = mutSelected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.mutationIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.mutationIdx = [...s].map(Number);
          ensurePlayState(m);
          renderWarband();

        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${pts} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        mutList.appendChild(line);
      });
      psiWrap.appendChild(mutList);
      

      // Summary box (unchanged from your original)
      const selectedPsy = (m.psychicIdx || []).map(i => psychicPowers[Number(i)]).filter(Boolean);
      const selectedMut = (m.mutationIdx || []).map(i => mutations[Number(i)]).filter(Boolean);

      const pmSummary = document.createElement("div");
      pmSummary.style.marginTop = "10px";
      pmSummary.style.padding = "10px 12px";
      pmSummary.style.border = "1px solid #eee";
      pmSummary.style.borderRadius = "10px";
      pmSummary.style.background = "#fafafa";
      pmSummary.style.fontSize = "13px";

      const pmHead = document.createElement("div");
      pmHead.style.fontWeight = "900";
      pmHead.textContent = "Selected Powers / Mutations";
      pmSummary.appendChild(pmHead);

      const addGroup = (groupTitle, arr) => {
        const t = document.createElement("div");
        t.style.marginTop = "8px";
        t.style.fontWeight = "800";
        t.textContent = groupTitle;
        pmSummary.appendChild(t);

        if (!arr.length) {
          const none = document.createElement("div");
          none.style.marginTop = "4px";
          none.style.color = "#666";
          none.textContent = "â€”";
          pmSummary.appendChild(none);
          return;
        }

        arr.forEach(obj => {
          const line = document.createElement("div");
          line.style.marginTop = "6px";
          line.style.whiteSpace = "pre-wrap";

          const nm = obj.name ?? "(Unnamed)";
          const pts = toIntOrNull(obj.points) ?? 0;
          const extra = getTextField(obj, ["power_type", "type"]) || getTextField(obj, ["range"]) || "";
          const eff = getTextField(obj, ["effect_text", "effect", "rule_text"]);
          line.textContent = `${nm} (${pts} pts)${extra ? " â€” " + extra : ""}${eff ? " â€” " + eff : ""}`.trim();
          pmSummary.appendChild(line);
        });
      };

      addGroup("Psychic Powers", selectedPsy);
      addGroup("Mutations", selectedMut);

      contentHost.appendChild(psiSection.wrap);
      contentHost.appendChild(pmSummary);
      }
      els.warbandGrid.appendChild(outer);
      
    });

    const total = warbandTotalPoints();
    els.warbandTotal.textContent = String(total);

    const cap = warband.pointCap;
    if (total > cap) {
      els.warbandCapStatus.innerHTML = `<span style="color:#8a1f11; font-weight:600;">Over cap by ${total - cap}</span>`;
    } else {
      els.warbandCapStatus.innerHTML = `<span style="color:#0b5; font-weight:600;">Within cap (${cap - total} left)</span>`;
    }
    saveWarbandToStorage();
  }

  function exportWarband() {
    warband.pointCap = toIntOrNull(els.pointCap.value) ?? 0;
    // NEW: make sure in-play fields are present before exporting
    warband.members.forEach(ensurePlayState);
    setIoVisible(true, "Export Warband");
    els.ioText.value = JSON.stringify(warband, null, 2);
    els.ioMsg.textContent = "Copy this JSON to save/share the warband.";
  }

  function importWarbandUI() {
    setIoVisible(true, "Import Warband");
    els.ioText.value = "";
    els.ioMsg.textContent = "Paste a previously exported warband JSON, then click â€œLoad Pasted JSONâ€.";
  }

  function loadPastedWarband() {
    try {
      const parsed = JSON.parse(els.ioText.value);
      if (!parsed || typeof parsed !== "object") throw new Error("Not an object");
      if (!Array.isArray(parsed.members)) throw new Error("Missing members[]");

      warband.version = parsed.version ?? warband.version;
      warband.pointCap = toIntOrNull(parsed.pointCap) ?? (toIntOrNull(els.pointCap.value) ?? warband.pointCap);

      warband.name = String(parsed.name ?? warband.name ?? "");
      if (els.warbandName) els.warbandName.value = warband.name ?? "";

      warband.warbandTraitIdx = (parsed.warbandTraitIdx === "" || parsed.warbandTraitIdx === null || parsed.warbandTraitIdx === undefined)
        ? "" : String(parsed.warbandTraitIdx);

      warband.leaderTraitIdx = (parsed.leaderTraitIdx === "" || parsed.leaderTraitIdx === null || parsed.leaderTraitIdx === undefined)
        ? "" : String(parsed.leaderTraitIdx);

      const defaultMembers = warband.members.map(m => ({
        ...m,
        weaponIdx: "", sidearmIdx: "", meleeIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [],
        woundsCurrent: null, horror: 0, hidden: false
      }));
      const incoming = parsed.members.slice(0, defaultMembers.length);

      warband.members = defaultMembers.map((def, i) => {
        const inc = incoming[i] ?? {};
        const merged = {
          role: def.role,
          name: String(inc.name ?? def.name ?? ""),
          defense: toIntOrNull(inc.defense) ?? def.defense,
          shoot: toIntOrNull(inc.shoot) ?? def.shoot,
          fight: toIntOrNull(inc.fight) ?? def.fight,
          will: toIntOrNull(inc.will) ?? def.will,
          weaponIdx: (inc.weaponIdx === "" || inc.weaponIdx === null || inc.weaponIdx === undefined) ? "" : String(inc.weaponIdx),
          sidearmIdx: (inc.sidearmIdx === "" || inc.sidearmIdx === null || inc.sidearmIdx === undefined) ? "" : String(inc.sidearmIdx),
          meleeIdx: (inc.meleeIdx === "" || inc.meleeIdx === null || inc.meleeIdx === undefined) ? "" : String(inc.meleeIdx),
          accessoryIdx: Array.isArray(inc.accessoryIdx) ? inc.accessoryIdx.map(Number).filter(n => Number.isFinite(n)) : [],
          psychicIdx: Array.isArray(inc.psychicIdx) ? inc.psychicIdx.map(Number).filter(n => Number.isFinite(n)) : [],
          mutationIdx: Array.isArray(inc.mutationIdx) ? inc.mutationIdx.map(Number).filter(n => Number.isFinite(n)) : [],
          // NEW: in-play fields (optional in older exports)
          woundsCurrent: toIntOrNull(inc.woundsCurrent),
          horror: toIntOrNull(inc.horror) ?? 0,
          hidden: (typeof inc.hidden === "boolean") ? inc.hidden : false,
        };
        ensurePlayState(merged);
        return merged;
      });

      els.pointCap.value = String(warband.pointCap);
      if (els.warbandTraitSelect) els.warbandTraitSelect.value = warband.warbandTraitIdx === "" ? "" : String(warband.warbandTraitIdx);
      if (els.leaderTraitSelect) els.leaderTraitSelect.value = warband.leaderTraitIdx === "" ? "" : String(warband.leaderTraitIdx);

      renderTraitDescriptions();
      renderWarband();
      els.ioMsg.textContent = "Loaded warband successfully.";
    } catch (e) {
      els.ioMsg.textContent = `Import failed: ${String(e.message || e)}`;
    }
  }

  async function loadData() {
    try {
      const wRes = await fetch("./data/shoot.json", { cache: "no-store" });
      if (!wRes.ok) throw new Error(`HTTP ${wRes.status} when fetching shoot.json`);
      weapons = await wRes.json();
      if (!Array.isArray(weapons)) throw new Error("shoot.json must be an array of objects");

      const aRes = await fetch("./data/accessories.json", { cache: "no-store" });
      if (!aRes.ok) throw new Error(`HTTP ${aRes.status} when fetching accessories.json`);
      accessories = await aRes.json();
      if (!Array.isArray(accessories)) throw new Error("accessories.json must be an array of objects");

      const fRes = await fetch("./data/fight.json", { cache: "no-store" });
      if (!fRes.ok) throw new Error(`HTTP ${fRes.status} when fetching fight.json`);
      meleeWeapons = await fRes.json();
      if (!Array.isArray(meleeWeapons)) throw new Error("fight.json must be an array of objects");

      const pRes = await fetch("./data/psychic_powers.json", { cache: "no-store" });
      if (!pRes.ok) throw new Error(`HTTP ${pRes.status} when fetching psychic_powers.json`);
      psychicPowers = await pRes.json();
      if (!Array.isArray(psychicPowers)) throw new Error("psychic_powers.json must be an array of objects");

      const mRes = await fetch("./data/mutations.json", { cache: "no-store" });
      if (!mRes.ok) throw new Error(`HTTP ${mRes.status} when fetching mutations.json`);
      mutations = await mRes.json();
      if (!Array.isArray(mutations)) throw new Error("mutations.json must be an array of objects");

      const wtRes = await fetch("./data/warband_traits.json", { cache: "no-store" });
      if (!wtRes.ok) throw new Error(`HTTP ${wtRes.status} when fetching warband_traits.json`);
      warbandTraits = await wtRes.json();
      if (!Array.isArray(warbandTraits)) throw new Error("warband_traits.json must be an array of objects");

      const ltRes = await fetch("./data/leader_traits.json", { cache: "no-store" });
      if (!ltRes.ok) throw new Error(`HTTP ${ltRes.status} when fetching leader_traits.json`);
      leaderTraits = await ltRes.json();
      if (!Array.isArray(leaderTraits)) throw new Error("leader_traits.json must be an array of objects");

      weapons.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      accessories.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      psychicPowers.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      mutations.sort((a, b) =>
        ((toIntOrNull(b.points) ?? 0) - (toIntOrNull(a.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      meleeWeapons.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );

      warbandTraits.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      leaderTraits.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );


      // IO buttons
      els.exportBtn.addEventListener("click", exportWarband);
      els.importBtn.addEventListener("click", importWarbandUI);
      els.closeIoBtn.addEventListener("click", () => setIoVisible(false));
  if (els.randomWarbandBtn) {
  els.randomWarbandBtn.addEventListener("click", () => {
    randomizeWarband();
    saveWarbandToStorage(); // optional, but nice so refresh keeps it
  });
}

      
      els.copyBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(els.ioText.value);
          els.ioMsg.textContent = "Copied to clipboard.";
        } catch {
          els.ioMsg.textContent = "Could not copy automatically â€” select all and copy manually.";
        }
      });
      els.loadBtn.addEventListener("click", loadPastedWarband);
      
// Load saved warband if present (so reload doesnâ€™t wipe selections)
loadWarbandFromStorage();

// reflect loaded values into UI controls
els.pointCap.value = String(warband.pointCap ?? 75);
if (els.warbandName) els.warbandName.value = warband.name ?? "";
if (els.warbandTraitSelect) els.warbandTraitSelect.value = warband.warbandTraitIdx === "" ? "" : String(warband.warbandTraitIdx);
if (els.leaderTraitSelect)  els.leaderTraitSelect.value  = warband.leaderTraitIdx  === "" ? "" : String(warband.leaderTraitIdx);

renderTraitDescriptions();
warband.members.forEach(ensurePlayState);
renderWarband();

      // Warband Trait select
      els.warbandTraitSelect.innerHTML =
        `<option value="">â€” None â€”</option>` +
        warbandTraits.map((t, idx) => {
          const nm = escapeHtml(t.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm}</option>`;
        }).join("");
      els.warbandTraitSelect.value = warband.warbandTraitIdx === "" ? "" : String(warband.warbandTraitIdx);
      renderTraitDescriptions();
      els.warbandTraitSelect.addEventListener("change", () => {
        warband.warbandTraitIdx = els.warbandTraitSelect.value === "" ? "" : els.warbandTraitSelect.value;
        renderTraitDescriptions();
        renderWarband();
      });

      // Leader Trait select
      els.leaderTraitSelect.innerHTML =
        `<option value="">â€” None â€”</option>` +
        leaderTraits.map((t, idx) => {
          const nm = escapeHtml(t.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm}</option>`;
        }).join("");
      els.leaderTraitSelect.value = warband.leaderTraitIdx === "" ? "" : String(warband.leaderTraitIdx);
      renderTraitDescriptions();
      els.leaderTraitSelect.addEventListener("change", () => {
        warband.leaderTraitIdx = els.leaderTraitSelect.value === "" ? "" : els.leaderTraitSelect.value;
        renderTraitDescriptions();
        renderWarband();
      });

      // Warband name input
      if (els.warbandName) {
        els.warbandName.value = warband.name ?? "";
        els.warbandName.addEventListener("input", () => { warband.name = els.warbandName.value; });
      }

      // Compact mode toggle (persisted)
      loadCompactPref();
      applyCompactMode(uiPrefs.compact);
      if (els.compactToggle) {
        els.compactToggle.checked = uiPrefs.compact;
        els.compactToggle.addEventListener("change", () => applyCompactMode(els.compactToggle.checked));
      }

      // Dice Tray
// Dice Tray (mobile-safe)
if (els.rollD20Btn && els.d20Result) {
  const doRoll = () => {
    const token = ++d20RollToken;

    // cancel any in-flight timers (important on mobile)
    if (d20FlickerTimer) { clearInterval(d20FlickerTimer); d20FlickerTimer = null; }
    if (d20FinalTimer)   { clearTimeout(d20FinalTimer);   d20FinalTimer = null; }

    els.rollD20Btn.disabled = true;

    // restart animation
    els.d20Result.classList.remove("dice-rolling");
    void els.d20Result.offsetWidth;
    els.d20Result.classList.add("dice-rolling");

    const start = Date.now();

    d20FlickerTimer = setInterval(() => {
      if (token !== d20RollToken) return;

      els.d20Result.textContent = String(rollDie(20));

      if (Date.now() - start > 350) {
        clearInterval(d20FlickerTimer);
        d20FlickerTimer = null;
      }
    }, 45);

    d20FinalTimer = setTimeout(() => {
      if (token !== d20RollToken) return;

      // ensure flicker is fully stopped before final write
      if (d20FlickerTimer) { clearInterval(d20FlickerTimer); d20FlickerTimer = null; }

      const r = rollDie(20);
      els.d20Result.textContent = String(r);

      diceState.history.unshift(r);
      diceState.history = diceState.history.slice(0, 10);
      renderDice();

      els.rollD20Btn.disabled = false;
      d20FinalTimer = null;
    }, 380);
  };

  // Use pointerup for mobile consistency
  els.rollD20Btn.addEventListener("pointerup", (e) => {
    e.preventDefault();
    doRoll();
  });
}


      // Clear dice
      if (els.clearRollsBtn) {
        els.clearRollsBtn.addEventListener("click", () => {
          diceState.history = [];
          if (els.d20Result) els.d20Result.textContent = "â€”";
          renderDice();
        });
      }

      renderDice();

      // Ensure play state defaults
      warband.members.forEach(ensurePlayState);

      renderWarband();
    } catch (err) {
      els.errorCard.style.display = "block";
      els.errorText.textContent = String(err);
      console.error(err);
    }
  }

  loadData();
</script>

</body>
</html>
