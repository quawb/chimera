<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chimera — Warband Builder (Prototype)</title>

  <div class="sub">
    <a href="./rules.html">Rules</a>
  </div>

  <div class="sub">
    <a href="./sandbox.html">Sandbox</a>
  </div>

  <div class="card" style="margin-top:12px;">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div style="font-weight:900;">Dice</div>

      <button id="rollD20Btn" type="button"
        style="padding:8px 12px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer;">
        Roll d20
      </button>

      <div style="display:flex; gap:8px; align-items:baseline;">
        <div style="color:#666;">Result</div>
        <div id="d20Result" class="dice-result" style="font-size:22px; font-weight:900;">—</div>
      </div>

      <button id="clearRollsBtn" type="button"
        style="padding:8px 12px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer;">
        Clear
      </button>
    </div>

    <div id="d20History" style="margin-top:10px; color:#444; font-size:14px;"></div>
  </div>

  <style>
    /* Dice animation */
    .dice-result { display: inline-block; min-width: 2ch; }
    .dice-rolling { animation: diceSpin 0.45s ease-in-out; }
    @keyframes diceSpin {
      0%   { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
      25%  { transform: translateY(-4px) rotate(6deg) scale(1.08); opacity: 0.9; }
      50%  { transform: translateY(2px) rotate(-6deg) scale(0.98); opacity: 0.9; }
      75%  { transform: translateY(-2px) rotate(3deg) scale(1.04); opacity: 1; }
      100% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 24px;
      line-height: 1.35;
    }
    h1 { margin: 0 0 8px; }
    .sub { color: #444; margin: 0 0 24px; }

    .row {
      display: grid;
      grid-template-columns: 240px 1fr;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
    }

    select, input { font-size: 16px; padding: 8px; }

    .card {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 14px;
      margin-top: 16px;
      max-width: none;
    }

    .grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      align-items: start;
      margin-top: 12px;
    }

    .pill {
      display: inline-block;
      border: 1px solid #ddd;
      border-radius: 999px;
      padding: 4px 10px;
      margin: 4px 6px 0 0;
      font-size: 14px;
    }
    .warn { color: #8a1f11; font-weight: 600; }
    .ok { color: #0b5; font-weight: 600; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }

    #warbandGrid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      align-items: start;
    }
    #warbandGrid > div { min-width: 0; overflow: hidden; }
    #warbandGrid input, #warbandGrid select, #warbandGrid button {
      max-width: 100%;
      box-sizing: border-box;
    }
    #warbandGrid > div > div:first-child { flex-wrap: wrap; }

    #warbandName { max-width: 280px; padding: 6px 8px; font-size: 14px; }
    #pointCap { max-width: 96px; padding: 6px 8px; font-size: 14px; }
    /* Make trait descriptions span full row (prevents odd wrapping / overflow) */
    #warbandTraitDesc,
    #leaderTraitDesc {
  grid-column: 1 / -1;
  max-width: 100%;
}


    /* --- Compact mode --- */
    body.compact { margin: 16px; }
    body.compact .row { grid-template-columns: 140px 1fr; gap: 10px; margin-bottom: 8px; }
    body.compact select, body.compact input { font-size: 14px; padding: 6px 8px; }
    body.compact #warbandGrid { gap: 10px; }
    body.compact #warbandGrid > div { padding: 10px !important; }
    body.compact #warbandGrid > div > div { margin-top: 8px !important; }

    /* Compact: "read at a glance" per-model summary */
body.compact .compactHeadline{
  display: grid;
  grid-template-columns: 1fr 1fr;   /* 2 columns on phone */
  gap: 6px 10px;
  font-size: 12px;
  line-height: 1.15;
  background: #fff;
  border: 1px solid #eee;
  border-radius: 10px;
  padding: 8px;
}
body.compact .compactHeadline{
  border: 1px solid #e8e8e8;
  box-shadow: 0 1px 2px rgba(0,0,0,.04);
}


body.compact .compactHeadline .kv{
  min-width: 0;
}

body.compact .compactHeadline .k{
  display: block;
  font-weight: 800;
  font-size: 11px;
  color: #444;
  margin-bottom: 2px;
}

body.compact .compactHeadline .v{
  display: block;
  font-weight: 700;
  color: #111;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis; /* keeps it inside the card */
}

/* When the value is long (accessories/powers), allow wrapping instead of overflow */
body.compact .compactHeadline .v.wrap{
  white-space: normal;
  overflow: visible;
  text-overflow: unset;
}


    /* In-play controls */
    .playbar {
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid #eee;
      border-radius: 10px;
      background: #fafafa;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: center;
    }
    .playrow { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .counter {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #ddd;
      border-radius: 999px;
      padding: 4px 8px;
      background: #fff;
      user-select: none;
    }
    .counter button {
      width: 30px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fff;
      cursor: pointer;
      font-weight: 900;
      line-height: 1;
    }
    .counter .val {
      min-width: 48px;
      text-align: center;
      font-weight: 900;
    }
    .smallBtn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
    }

    /* Card visibility toggles */
    #modelVisibility {
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid #eee;
      border-radius: 10px;
      background: #fafafa;
    }
    #modelVisibility .mvGrid{
      margin-top: 8px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 8px 12px;
    }
    #modelVisibility label{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
      font-size: 13px;
      color:#333;
    }

    /* ---------- Mobile / small screens ---------- */
@media (max-width: 640px) {
  body { margin: 12px; }

  /* Stack label + control instead of 240px label column */
  .row {
    grid-template-columns: 1fr;
    gap: 6px;
  }

  /* Inputs stop being artificially narrow */
  #warbandName,
  #pointCap {
    max-width: none;
    width: 100%;
  }

  /* Model cards / grids: allow narrower columns */
  #warbandGrid {
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  }

  /* In-play tracker bars: stack instead of 2-up */
  .playbar {
    grid-template-columns: 1fr;
  }

  .playrow {
    flex-wrap: wrap;
    justify-content: flex-start;
  }

  .counter {
    width: 100%;
    justify-content: space-between;
  }

  .counter .val {
    min-width: 36px;
  }

  /* Optional: make the extra button (Full/Clear) not squeeze layout */
  .smallBtn {
    width: 100%;
  }
}
/* Compact: at-a-glance model summary (no horizontal spill) */
body.compact .compactHeadline{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px 10px;
  font-size: 12px;
  line-height: 1.15;
  background: #fff;
  border: 1px solid #eee;
  border-radius: 10px;
  padding: 8px;
  margin-top: 8px;
}

body.compact .compactHeadline .kv{ min-width: 0; }

body.compact .compactHeadline .k{
  display: block;
  font-weight: 800;
  font-size: 11px;
  color: #444;
  margin-bottom: 2px;
}

body.compact .compactHeadline .v{
  display: block;
  font-weight: 700;
  color: #111;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

body.compact .compactHeadline .v.wrap{
  white-space: normal;
  overflow: visible;
  text-overflow: unset;
}

  </style>
</head>

<body>
  <h1>Chimera Builder (Prototype)</h1>

  <div class="row">
    <label for="pointCap"><strong>Point Cap</strong></label>
    <input id="pointCap" type="number" value="75" min="0" step="1" />
  </div>

  <div class="row" style="margin-top:10px;">
    <label><strong>Display</strong></label>
    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none;">
      <input id="compactToggle" type="checkbox" />
      Compact mode
    </label>
  </div>

  <div class="card">
    <div style="display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center;">
      <div>
        <div style="font-size:18px; font-weight:800;">Warband</div>
        <div style="color:#444; margin-top:4px;">Leader + 4 models. Each model has its own weapon + accessories.</div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="exportBtn" type="button">Export Warband</button>
        <button id="importBtn" type="button">Import Warband</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="warbandName"><strong>Warband Name</strong></label>
      <input id="warbandName" type="text" placeholder="e.g., The Quawb Cult" style="width:100%;" />
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="warbandTraitSelect"><strong>Warband Trait</strong></label>
      <select id="warbandTraitSelect"></select>
      <div id="warbandTraitDesc" style="margin-top:6px; color:#444; font-size:13px;"></div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="leaderTraitSelect"><strong>Leader Trait</strong></label>
      <select id="leaderTraitSelect"></select>
      <div id="leaderTraitDesc" style="margin-top:6px; color:#444; font-size:13px;"></div>
    </div>

    <!-- NEW: per-model show/hide -->
    <div id="modelVisibility" style="display:none;">
      <div style="font-weight:900;">Show / hide model cards</div>
      <div class="mvGrid" id="modelVisibilityGrid"></div>
    </div>

    <div id="warbandGrid" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; margin-top:14px;"></div>

    <div style="margin-top:14px;">
      <div style="font-size:14px; color:#444;">Warband Total</div>
      <div style="font-size:28px; font-weight:900;" id="warbandTotal">0</div>
      <div id="warbandCapStatus" style="margin-top:6px;"></div>
    </div>

    <div id="ioArea" style="display:none; margin-top:14px;">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
        <strong id="ioTitle">Export / Import</strong>
        <button id="closeIoBtn" type="button">Close</button>
      </div>
      <textarea id="ioText" rows="10" style="width:100%; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; padding:10px;"></textarea>
      <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
        <button id="copyBtn" type="button">Copy</button>
        <button id="loadBtn" type="button">Load Pasted JSON</button>
      </div>
      <div id="ioMsg" style="margin-top:8px; color:#444;"></div>
    </div>
  </div>

  <div class="card" id="errorCard" style="display:none;">
    <div class="warn">Could not load shoot.json</div>
    <p id="errorText" style="margin:8px 0 0;"></p>
    <p style="margin:8px 0 0;">
      Expected path: <code>site/data/shoot.json</code>
    </p>
  </div>

<script>
  const els = {
    rollD20Btn: document.getElementById("rollD20Btn"),
    clearRollsBtn: document.getElementById("clearRollsBtn"),
    d20Result: document.getElementById("d20Result"),
    d20History: document.getElementById("d20History"),

    compactToggle: document.getElementById("compactToggle"),
    warbandName: document.getElementById("warbandName"),

    pointCap: document.getElementById("pointCap"),
    warbandGrid: document.getElementById("warbandGrid"),
    warbandTotal: document.getElementById("warbandTotal"),
    warbandCapStatus: document.getElementById("warbandCapStatus"),

    warbandTraitSelect: document.getElementById("warbandTraitSelect"),
    leaderTraitSelect: document.getElementById("leaderTraitSelect"),
    warbandTraitDesc: document.getElementById("warbandTraitDesc"),
    leaderTraitDesc: document.getElementById("leaderTraitDesc"),

    exportBtn: document.getElementById("exportBtn"),
    importBtn: document.getElementById("importBtn"),
    ioArea: document.getElementById("ioArea"),
    ioTitle: document.getElementById("ioTitle"),
    ioText: document.getElementById("ioText"),
    copyBtn: document.getElementById("copyBtn"),
    loadBtn: document.getElementById("loadBtn"),
    closeIoBtn: document.getElementById("closeIoBtn"),
    ioMsg: document.getElementById("ioMsg"),

    modelVisibility: document.getElementById("modelVisibility"),
    modelVisibilityGrid: document.getElementById("modelVisibilityGrid"),

    errorCard: document.getElementById("errorCard"),
    errorText: document.getElementById("errorText"),
  };

  const diceState = { history: [] }; // newest first
  function rollDie(sides) { return Math.floor(Math.random() * sides) + 1; }
  function renderDice() {
    if (!els.d20History) return;
    els.d20History.textContent = diceState.history.length
      ? "History: " + diceState.history.join(", ")
      : "History: —";
  }

  function toIntOrNull(v) {
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (s === "") return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  // UI preferences
  const uiPrefs = { compact: false };
  function applyCompactMode(on) {
    uiPrefs.compact = !!on;
    document.body.classList.toggle("compact", uiPrefs.compact);
    try { localStorage.setItem("chimera_compact", uiPrefs.compact ? "1" : "0"); } catch {}
  }
  function loadCompactPref() {
    try {
      const v = localStorage.getItem("chimera_compact");
      if (v === "1") uiPrefs.compact = true;
    } catch {}
  }

  function escapeHtml(str) {
    return String(str ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function getTextField(obj, keys) {
    for (const k of keys) {
      const v = obj?.[k];
      if (v !== undefined && v !== null && String(v).trim() !== "") return String(v);
    }
    return "";
  }

  // Data tables (loaded from JSON)
  let weapons = [];
  let accessories = [];
  let psychicPowers = [];
  let mutations = [];
  let meleeWeapons = [];
  let warbandTraits = [];
  let leaderTraits = [];

  // === Rules (hardwired for now, easy to change) ===
  const DEFENSE_TO_ACC_CAP = { 0: 0, 1: 1, 2: 2, 3: 3 };
  const SIDEARM_UNLOCK_SHOOT_TIER = 3;

  // === Stat costs + modifiers (hard-coded) ===
  const DEF_WILL_TABLE = {
    0: { mod: -2, cost: 0 },
    1: { mod: 0,  cost: 2 },
    2: { mod: 2,  cost: 4 },
    3: { mod: 4,  cost: 8 },
  };
  const SHOOT_FIGHT_TABLE = {
    0: { mod: -2, cost: 0 },
    1: { mod: -2, cost: 0 },
    2: { mod: 2,  cost: 3 },
    3: { mod: 4,  cost: 6 },
  };
  const SAVE_TARGET_BY_WILL = { 0: 14, 1: 14, 2: 13, 3: 11 };
  function clampMin(n, min) { return n < min ? min : n; }
  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

  function defenseMod(tier) { return (DEF_WILL_TABLE[tier] ?? DEF_WILL_TABLE[1]).mod; }
  function willMod(tier)    { return (DEF_WILL_TABLE[tier] ?? DEF_WILL_TABLE[1]).mod; }
  function shootMod(tier)   { return (SHOOT_FIGHT_TABLE[tier] ?? SHOOT_FIGHT_TABLE[1]).mod; }
  function fightMod(tier)   { return (SHOOT_FIGHT_TABLE[tier] ?? SHOOT_FIGHT_TABLE[1]).mod; }

  function statPointsCost(m) {
    const d = (DEF_WILL_TABLE[m.defense] ?? DEF_WILL_TABLE[1]).cost;
    const w = (DEF_WILL_TABLE[m.will] ?? DEF_WILL_TABLE[1]).cost;
    const s = (SHOOT_FIGHT_TABLE[m.shoot] ?? SHOOT_FIGHT_TABLE[1]).cost;
    const f = (SHOOT_FIGHT_TABLE[m.fight] ?? SHOOT_FIGHT_TABLE[1]).cost;
    return d + w + s + f;
  }

  function woundsTotal(m) {
    return (m.defense ?? 0) + (m.shoot ?? 0) + (m.fight ?? 0) + (m.will ?? 0);
  }

  function equipmentCapacity(m) { return m.defense ?? 0; }
  function psychicMutationCapacity(m) { return m.will ?? 0; }
  function savingThrowTarget(m) { return clampMin((SAVE_TARGET_BY_WILL[m.will] ?? SAVE_TARGET_BY_WILL[1]), 10); }
  function armorClass(m) { return 10 + defenseMod(m.defense ?? 1); }

  // NEW: ensure in-play state fields exist + stay clamped
  function ensurePlayState(m) {
    const maxW = woundsTotal(m);
    if (!Number.isFinite(Number(m.woundsCurrent))) m.woundsCurrent = maxW; // default to full
    m.woundsCurrent = clamp(Number(m.woundsCurrent), 0, maxW);

    if (!Number.isFinite(Number(m.horror))) m.horror = 0;
    m.horror = clamp(Number(m.horror), 0, 5);

    if (typeof m.hidden !== "boolean") m.hidden = false;
  }

  // Warband state: leader + 4 models
  const warband = {
    version: 4, // bumped because we added in-play fields
    name: "Unnamed Warband",
    pointCap: 75,
    warbandTraitIdx: "",
    leaderTraitIdx: "",
    members: [
      { role: "Leader", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 1", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 2", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 3", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
      { role: "Model 4", name: "", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [], meleeIdx: "", woundsCurrent: null, horror: 0, hidden: false },
    ]
  };

  // Remember which collapsibles are open per member index
  const openPanelsByMember = new Map(); // memberIndex -> { accessories: true/false, psi: true/false }

  function memberWeaponPoints(m) {
    let sum = 0;

    if (m.weaponIdx !== "" && m.weaponIdx !== null && m.weaponIdx !== undefined) {
      const w = weapons[Number(m.weaponIdx)];
      sum += toIntOrNull(w?.points) ?? 0;
    }

    if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER &&
        m.sidearmIdx !== "" && m.sidearmIdx !== null && m.sidearmIdx !== undefined) {
      const s = weapons[Number(m.sidearmIdx)];
      sum += toIntOrNull(s?.points) ?? 0;
    }

    if (m.meleeIdx !== "" && m.meleeIdx !== null && m.meleeIdx !== undefined) {
      const mw = meleeWeapons[Number(m.meleeIdx)];
      sum += toIntOrNull(mw?.points) ?? 0;
    }

    return sum;
  }

  function memberAccessoryPoints(m) {
    let sum = 0;
    for (const idx of (m.accessoryIdx || [])) {
      const a = accessories[Number(idx)];
      sum += (toIntOrNull(a?.points) ?? 0);
    }
    return sum;
  }

  function memberPsiMutPoints(m) {
    let sum = 0;
    for (const idx of (m.psychicIdx || [])) {
      const p = psychicPowers[Number(idx)];
      sum += (toIntOrNull(p?.points) ?? 0);
    }
    for (const idx of (m.mutationIdx || [])) {
      const mu = mutations[Number(idx)];
      sum += (toIntOrNull(mu?.points) ?? 0);
    }
    return sum;
  }

  function clearMemberLoadout(m) {
    m.weaponIdx = "";
    m.sidearmIdx = "";
    m.meleeIdx = "";
    m.accessoryIdx = [];
    m.psychicIdx = [];
    m.mutationIdx = [];
  }

  function memberTotalPoints(m) {
    return statPointsCost(m) + memberWeaponPoints(m) + memberAccessoryPoints(m) + memberPsiMutPoints(m);
  }

  function warbandTotalPoints() {
    return warband.members.reduce((acc, m) => acc + memberTotalPoints(m), 0);
  }

  function makeCollapsible(titleText, initiallyOpen = false, onToggle = null) {
    const wrap = document.createElement("div");
    wrap.style.marginTop = "12px";
    wrap.style.border = "1px solid #eee";
    wrap.style.borderRadius = "10px";
    wrap.style.overflow = "hidden";

    const header = document.createElement("button");
    header.type = "button";
    header.style.width = "100%";
    header.style.textAlign = "left";
    header.style.padding = "10px 12px";
    header.style.border = "0";
    header.style.background = "#f7f7f7";
    header.style.cursor = "pointer";
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    header.style.fontWeight = "800";

    const title = document.createElement("span");
    title.textContent = titleText;

    const chevron = document.createElement("span");
    chevron.textContent = initiallyOpen ? "▾" : "▸";
    chevron.style.opacity = "0.8";

    header.appendChild(title);
    header.appendChild(chevron);

    const body = document.createElement("div");
    body.style.padding = "10px 12px";
    body.style.display = initiallyOpen ? "block" : "none";
    body.style.background = "#fff";

    function setOpen(open) {
      body.style.display = open ? "block" : "none";
      chevron.textContent = open ? "▾" : "▸";
      if (typeof onToggle === "function") onToggle(open);
    }

    header.addEventListener("click", () => {
      const open = body.style.display === "none";
      setOpen(open);
    });

    wrap.appendChild(header);
    wrap.appendChild(body);

    return { wrap, body, setOpen };
  }

  function setIoVisible(vis, title) {
    els.ioArea.style.display = vis ? "block" : "none";
    if (title) els.ioTitle.textContent = title;
    els.ioMsg.textContent = "";
  }

  function traitDescription(obj) {
    const txt = obj?.effect_text ?? obj?.effect ?? obj?.rule_text ?? "";
    return String(txt ?? "").trim();
  }

  function renderTraitDescriptions() {
    if (els.warbandTraitDesc) {
      if (warband.warbandTraitIdx === "") els.warbandTraitDesc.textContent = "";
      else els.warbandTraitDesc.textContent = traitDescription(warbandTraits[Number(warband.warbandTraitIdx)]) || "—";
    }
    if (els.leaderTraitDesc) {
      if (warband.leaderTraitIdx === "") els.leaderTraitDesc.textContent = "";
      else els.leaderTraitDesc.textContent = traitDescription(leaderTraits[Number(warband.leaderTraitIdx)]) || "—";
    }
  }

  function makeSelectedWeaponsSummary(m) {
    const box = document.createElement("div");
    box.style.marginTop = "10px";
    box.style.padding = "10px 12px";
    box.style.border = "1px solid #eee";
    box.style.borderRadius = "10px";
    box.style.background = "#fafafa";
    box.style.fontSize = "13px";

    const head = document.createElement("div");
    head.style.fontWeight = "900";
    head.textContent = "Selected Weapons";
    box.appendChild(head);

    function weaponLine(label, w) {
      const row = document.createElement("div");
      row.style.marginTop = "8px";
      row.style.whiteSpace = "pre-wrap";

      if (!w) {
        row.textContent = `${label}: —`;
        row.style.color = "#666";
        return row;
      }

      const name = w.name ?? "(Unnamed)";
      const pts = toIntOrNull(w.points) ?? 0;

      const actions = (w.max_actions !== undefined && String(w.max_actions).trim() !== "") ? `A:${w.max_actions}` : "";
      const dmg = (w.damage !== undefined && String(w.damage).trim() !== "") ? `D:${w.damage}` : "";
      const ap = (w.ap !== undefined && String(w.ap).trim() !== "") ? `AP:${w.ap}` : "";

      const statBits = [actions, dmg, ap].filter(Boolean).join(" · ");
      const eff = getTextField(w, ["effect_text", "effect", "rule_text"]);

      row.textContent =
        `${label}: ${name} (${pts} pts)` +
        (statBits ? ` — ${statBits}` : "") +
        (eff ? ` — ${eff}` : "");

      return row;
    }

    const ranged = (m.weaponIdx === "" ? null : weapons[Number(m.weaponIdx)]);
    const sidearm =
      ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER && m.sidearmIdx !== "")
        ? weapons[Number(m.sidearmIdx)]
        : null;
    const melee = (m.meleeIdx === "" ? null : meleeWeapons[Number(m.meleeIdx)]);

    box.appendChild(weaponLine("Ranged", ranged));
    if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER) box.appendChild(weaponLine("Sidearm", sidearm));
    box.appendChild(weaponLine("Melee", melee));

    return box;
  }

  function makeSelectedAccessoriesSummary(m) {
    const box = document.createElement("div");
    box.style.marginTop = "10px";
    box.style.padding = "10px 12px";
    box.style.border = "1px solid #eee";
    box.style.borderRadius = "10px";
    box.style.background = "#fafafa";
    box.style.fontSize = "13px";

    const head = document.createElement("div");
    head.style.fontWeight = "900";
    head.textContent = "Selected Accessories";
    box.appendChild(head);

    const chosen = (m.accessoryIdx || [])
      .map(i => accessories[Number(i)])
      .filter(Boolean);

    if (!chosen.length) {
      const none = document.createElement("div");
      none.style.marginTop = "8px";
      none.style.color = "#666";
      none.textContent = "—";
      box.appendChild(none);
      return box;
    }

    chosen.forEach(a => {
      const row = document.createElement("div");
      row.style.marginTop = "8px";
      row.style.whiteSpace = "pre-wrap";

      const name = a.name ?? "(Unnamed)";
      const pts = toIntOrNull(a.points) ?? 0;
      const eff = getTextField(a, ["effect_text", "effect", "rule_text"]);

      row.textContent = `${name} (${pts} pts)` + (eff ? ` — ${eff}` : "");
      box.appendChild(row);
    });

    return box;
  }

  // NEW: headline shows current wounds + horror
function makeStatsHeadline(m) {
  ensurePlayState(m);
  const isCompact = document.body.classList.contains("compact");

  // Helpers
  const safeName = (x) => (x && (x.name ?? x.title ?? x.label)) ? String(x.name ?? x.title ?? x.label) : "";
  const joinNames = (arr, lookup) =>
    (arr || []).map((idx) => safeName(lookup[Number(idx)])).filter(Boolean).join(", ");


// Weapons (Ranged / Sidearm / Melee)
const rangedName =
  (m.weaponIdx !== "" && m.weaponIdx != null)
    ? (safeName(weapons[Number(m.weaponIdx)]) || "—")
    : "—";

const sidearmUnlocked = (m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER;
const sidearmName =
  (sidearmUnlocked && m.sidearmIdx !== "" && m.sidearmIdx != null)
    ? (safeName(weapons[Number(m.sidearmIdx)]) || "—")
    : (sidearmUnlocked ? "—" : "n/a");

const meleeName =
  (m.meleeIdx !== "" && m.meleeIdx != null)
    ? (safeName(meleeWeapons[Number(m.meleeIdx)]) || "—")
    : "—";

  // Sidearm (if unlocked + selected)
  const sidearmUnlocked = (m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER;
  if (sidearmUnlocked && m.sidearmIdx !== "" && m.sidearmIdx !== null && m.sidearmIdx !== undefined) {
    const s = safeName(weapons[Number(m.sidearmIdx)]) || "";
    if (s) weaponText += ` / ${s}`;
  }

  const accText = joinNames(m.accessoryIdx, accessories) || "—";

  const psiText = joinNames(m.psychicIdx, psychicPowers) || "";
  const mutText = joinNames(m.mutationIdx, mutations) || "";
  const psiMutText = (psiText && mutText) ? `${psiText}; ${mutText}` : (psiText || mutText || "—");

  // AC / Save / Wounds / Horror
  const ac = armorClass(m);
  const saveT = savingThrowTarget(m);
  const maxW = woundsTotal(m);

  // Modifiers
  const dMod = defenseMod(m.defense ?? 1);
  const sMod = shootMod(m.shoot ?? 1);
  const fMod = fightMod(m.fight ?? 1);
  const wMod = willMod(m.will ?? 1);

  const fmtSigned = (n) => {
    const v = Number(n) || 0;
    return (v >= 0 ? `+${v}` : `${v}`);
  };

  // Desktop / non-compact: keep it simple
  if (!isCompact) {
    const line = document.createElement("div");
    line.style.marginTop = "8px";
    line.style.padding = "8px 10px";
    line.style.background = "#fff";
    line.style.fontSize = "13px";
    line.style.fontWeight = "700";
    line.style.color = "#333";
    line.textContent =
      `Weapon: ${weaponText} • Acc: ${accText} • Psi/Mut: ${psiMutText} • ` +
      `AC ${ac} • Save ${saveT} • Wounds ${m.woundsCurrent}/${maxW} • Horror ${m.horror}/5 • ` +
      `Mods D${fmtSigned(dMod)} S${fmtSigned(sMod)} F${fmtSigned(fMod)} W${fmtSigned(wMod)}`;
    return line;
  }

  // Compact: 2-col "at a glance" grid
  const wrap = document.createElement("div");
  wrap.className = "compactHeadline";

  const addKV = (k, v, wrapValue = false) => {
    const kv = document.createElement("div");
    kv.className = "kv";

    const kk = document.createElement("span");
    kk.className = "k";
    kk.textContent = k;

    const vv = document.createElement("span");
    vv.className = "v" + (wrapValue ? " wrap" : "");
    vv.textContent = v;

    kv.appendChild(kk);
    kv.appendChild(vv);
    wrap.appendChild(kv);
  };

  addKV("Weapons", `R: ${rangedName} • M: ${meleeName}` + (sidearmUnlocked ? ` • P: ${sidearmName}` : ""), true);
  addKV("Accessories", accText, true);
  addKV("Powers / Mut", psiMutText, true);
  addKV("AC / Save", `AC ${ac} • Save ${saveT}`);
  addKV("Wounds / Horror", `${m.woundsCurrent}/${maxW} • H ${m.horror}/5`);
  addKV("Mods", `D${fmtSigned(dMod)} S${fmtSigned(sMod)} F${fmtSigned(fMod)} W${fmtSigned(wMod)}`);

  return wrap;
}



  // NEW: show/hide list above grid
  function renderModelVisibilityControls() {
    if (!els.modelVisibility || !els.modelVisibilityGrid) return;

    els.modelVisibilityGrid.innerHTML = "";
    els.modelVisibility.style.display = "block";

    warband.members.forEach((m, i) => {
      ensurePlayState(m);
      const id = `show_m_${i}`;
      const label = document.createElement("label");

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.id = id;
      cb.checked = !m.hidden;

      cb.addEventListener("change", () => {
        m.hidden = !cb.checked;
        renderWarband();
      });

      const name = (m.name && String(m.name).trim()) ? ` — ${m.name}` : "";
      const txt = document.createElement("span");
      txt.textContent = `${m.role}${name}`;

      label.appendChild(cb);
      label.appendChild(txt);
      els.modelVisibilityGrid.appendChild(label);
    });
  }

  // NEW: in-play +/- control factory
  function makeCounter(labelText, getText, onMinus, onPlus, extraBtnText, onExtra) {
    const row = document.createElement("div");
    row.className = "playrow";

    const l = document.createElement("div");
    l.style.fontWeight = "900";
    l.style.color = "#333";
    l.textContent = labelText;

    const c = document.createElement("div");
    c.className = "counter";

    const minus = document.createElement("button");
    minus.type = "button";
    minus.textContent = "−";
    minus.addEventListener("click", onMinus);

    const val = document.createElement("div");
    val.className = "val";
    val.textContent = getText();

    const plus = document.createElement("button");
    plus.type = "button";
    plus.textContent = "+";
    plus.addEventListener("click", onPlus);

    c.appendChild(minus);
    c.appendChild(val);
    c.appendChild(plus);

    row.appendChild(l);
    row.appendChild(c);

    if (extraBtnText && typeof onExtra === "function") {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "smallBtn";
      b.textContent = extraBtnText;
      b.addEventListener("click", onExtra);
      row.appendChild(b);
    }

    return { row, setValueText: (t) => (val.textContent = t) };
  }

  function renderWarband() {
    warband.pointCap = toIntOrNull(els.pointCap.value) ?? 0;

    // NEW: draw show/hide controls
    renderModelVisibilityControls();

    els.warbandGrid.innerHTML = "";
    const collapseModelsOnPhone =
  document.body.classList.contains("compact") &&
  window.matchMedia("(max-width: 480px)").matches;


    warband.members.forEach((m, memberIndex) => {
      ensurePlayState(m);

      // If hidden, still keep state, just don't render card
      if (m.hidden) return;

      const card = document.createElement("div");
      card.style.border = "1px solid #ddd";
      card.style.borderRadius = "10px";
      card.style.padding = "14px";

      // Header
      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.justifyContent = "space-between";
      header.style.alignItems = "baseline";
      header.style.gap = "10px";

      const title = document.createElement("div");
      title.style.display = "flex";
      title.style.flexDirection = "column";
      title.style.gap = "6px";

      const roleLine = document.createElement("div");
      roleLine.style.fontWeight = "900";
      roleLine.style.fontSize = "16px";
      roleLine.textContent = m.role;

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.placeholder = `${m.role} name`;
      nameInput.value = m.name ?? "";
      nameInput.style.width = "100%";
      nameInput.addEventListener("input", () => {
        m.name = nameInput.value;
        // update show/hide labels without re-rendering everything
        renderModelVisibilityControls();
      });

      title.appendChild(roleLine);
      title.appendChild(nameInput);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";
      right.style.gap = "10px";

      const pts = document.createElement("div");
      pts.style.fontWeight = "800";
      pts.textContent = `${memberTotalPoints(m)} pts`;

      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.textContent = "Clear Loadout";
      clearBtn.style.padding = "6px 10px";
      clearBtn.style.borderRadius = "10px";
      clearBtn.style.border = "1px solid #ddd";
      clearBtn.style.background = "#fff";
      clearBtn.style.cursor = "pointer";
      clearBtn.addEventListener("click", () => {
        clearMemberLoadout(m);
        renderWarband();
      });

      right.appendChild(pts);
      right.appendChild(clearBtn);

      header.appendChild(title);
      header.appendChild(right);
      
      // In phone-compact view, wrap the whole model UI in a collapsible
let outer = card;
let contentHost = card;

if (collapseModelsOnPhone) {
  // Title shown when collapsed (keep it short)
  const nm = (m.name && String(m.name).trim()) ? ` — ${m.name.trim()}` : "";
  const titleText = `${m.role}${nm} (${memberTotalPoints(m)} pts)`;

  // Open Leader by default, others closed
  const col = makeCollapsible(titleText, memberIndex === 0);

  // Make the collapsible body feel like the old card (padding, etc.)
  col.body.style.padding = "12px";
  col.body.style.background = "#fff";

  // Put original card content into collapsible body instead of the grid
  outer = col.wrap;
  contentHost = col.body;
}
contentHost.appendChild(header);


      // Tier select helper (shows Tier + mod)
      function tierSelect(label, key) {
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.flexDirection = "column";
        wrap.style.gap = "8px";
        wrap.style.alignItems = "center";

        const l = document.createElement("div");
        l.innerHTML = `<strong>${escapeHtml(label)}</strong>`;

        const s = document.createElement("select");
        s.style.width = "100%";
        const tiers = [1, 2, 3];
        const table =
          (key === "defense" || key === "will") ? DEF_WILL_TABLE :
          (key === "shoot" || key === "fight") ? SHOOT_FIGHT_TABLE :
          null;

        s.innerHTML = tiers.map(t => {
          const entry = table?.[t];
          const mod = entry?.mod ?? 0;
          const modStr = mod >= 0 ? `+${mod}` : `${mod}`;
          return `<option value="${t}">T${t} (${modStr})</option>`;
        }).join("");

        s.value = String(m[key] ?? 0);

        s.addEventListener("change", () => {
          m[key] = Number(s.value);
          if (key === "shoot" && (m.shoot ?? 0) < SIDEARM_UNLOCK_SHOOT_TIER) m.sidearmIdx = "";

          // NEW: re-clamp current wounds when max wounds change
          ensurePlayState(m);

          renderWarband();
        });

        wrap.appendChild(l);
        wrap.appendChild(s);
        return wrap;
      }

      // Stats block
      const statsBlock = document.createElement("div");
      statsBlock.style.marginTop = "10px";
      statsBlock.style.display = "grid";
      statsBlock.style.gridTemplateColumns = "repeat(auto-fit, minmax(240px, 1fr))";
      statsBlock.style.gap = "10px";
      
const isPlayMode = document.body.classList.contains("compact");

if (!isPlayMode) {
  statsBlock.appendChild(tierSelect("Defense", "defense"));
  statsBlock.appendChild(tierSelect("Shoot", "shoot"));
  statsBlock.appendChild(tierSelect("Fight", "fight"));
  statsBlock.appendChild(tierSelect("Willpower", "will"));
  contentHost.appendChild(statsBlock);
}

// Headline stats row (Play Mode only)
if (isPlayMode) {
  contentHost.appendChild(makeStatsHeadline(m));
}



      // NEW: In-play controls (Wounds +/- and Horror 0–5)
      const play = document.createElement("div");
      play.className = "playbar";

      const maxW = woundsTotal(m);

      const woundsCtl = makeCounter(
        "Wounds",
        () => `${m.woundsCurrent}/${maxW}`,
        () => { m.woundsCurrent = clamp(m.woundsCurrent - 1, 0, maxW); renderWarband(); },
        () => { m.woundsCurrent = clamp(m.woundsCurrent + 1, 0, maxW); renderWarband(); },
        "Full",
        () => { m.woundsCurrent = maxW; renderWarband(); }
      );

      const horrorCtl = makeCounter(
        "Horror",
        () => `${m.horror}/5`,
        () => { m.horror = clamp(m.horror - 1, 0, 5); renderWarband(); },
        () => { m.horror = clamp(m.horror + 1, 0, 5); renderWarband(); },
        "Clear",
        () => { m.horror = 0; renderWarband(); }
      );

      play.appendChild(woundsCtl.row);
      play.appendChild(horrorCtl.row);
      contentHost.appendChild(play);

      // Derived stats (collapsible)
      const statsSection = makeCollapsible("Stats", false);
      const derived = statsSection.body;

      derived.style.padding = "10px 12px";
      derived.style.background = "#fafafa";

      const statLine = (label, value) => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.justifyContent = "space-between";
        row.style.gap = "12px";
        row.style.marginTop = "6px";
        row.innerHTML = `<span style="color:#444;">${escapeHtml(label)}</span><span style="font-weight:800;">${escapeHtml(value)}</span>`;
        return row;
      };

      derived.appendChild(statLine("Armor Class (AC)", String(armorClass(m))));
      derived.appendChild(statLine("Saving Throw Target", String(savingThrowTarget(m))));
      derived.appendChild(statLine("Wounds (Max)", String(woundsTotal(m))));
      derived.appendChild(statLine("Accessory Slots", `${(m.accessoryIdx || []).length}/${equipmentCapacity(m)}`));
      derived.appendChild(statLine("Psi/Mut Slots", `${((m.psychicIdx || []).length + (m.mutationIdx || []).length)}/${psychicMutationCapacity(m)}`));
      derived.appendChild(statLine("Defense Mod", String(defenseMod(m.defense ?? 1))));
      derived.appendChild(statLine("Shoot Mod", String(shootMod(m.shoot ?? 1))));
      derived.appendChild(statLine("Fight Mod", String(fightMod(m.fight ?? 1))));
      derived.appendChild(statLine("Willpower Mod", String(willMod(m.will ?? 1))));
      derived.appendChild(statLine("Stat Points", String(statPointsCost(m))));
      derived.appendChild(statLine("Gear Points", String(memberWeaponPoints(m) + memberAccessoryPoints(m) + memberPsiMutPoints(m))));
      derived.appendChild(statLine("Model Total Points", String(memberTotalPoints(m))));
      contentHost.appendChild(statsSection.wrap);
      
if (!isPlayMode) {
      // Ranged Weapon
      const weaponRow = document.createElement("div");
      weaponRow.style.marginTop = "12px";
      weaponRow.innerHTML = "<strong>Ranged Weapon</strong>";

      const sel = document.createElement("select");
      sel.style.width = "100%";
      sel.style.marginTop = "6px";
      sel.innerHTML =
        `<option value="">— None —</option>` +
        weapons.map((w, idx) => {
          const p = toIntOrNull(w.points) ?? 0;
          const nm = escapeHtml(w.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm} (${p} pts)</option>`;
        }).join("");

      sel.value = m.weaponIdx === "" ? "" : String(m.weaponIdx);
      sel.addEventListener("change", () => {
        m.weaponIdx = sel.value === "" ? "" : sel.value;
        renderWarband();
      });

      weaponRow.appendChild(sel);
      contentHost.appendChild(weaponRow);

      // Sidearm (Shoot >= 3)
      if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER) {
        const sidearmRow = document.createElement("div");
        sidearmRow.style.marginTop = "10px";
        sidearmRow.innerHTML = "<strong>Sidearm (Shoot Tier 3+)</strong>";

        const sidearms = weapons
          .map((w, idx) => ({ w, idx }))
          .filter(x =>
            String(x.w.name ?? "").toLowerCase().includes("sidearm") ||
            String(x.w.name ?? "").toLowerCase().includes("pistol")
          );

        const sideSel = document.createElement("select");
        sideSel.style.width = "100%";
        sideSel.style.marginTop = "6px";
        sideSel.innerHTML =
          `<option value="">— None —</option>` +
          sidearms.map(x => {
            const p = toIntOrNull(x.w.points) ?? 0;
            const nm = escapeHtml(x.w.name ?? "(Unnamed)");
            return `<option value="${x.idx}">${nm} (${p} pts)</option>`;
          }).join("");

        sideSel.value = m.sidearmIdx === "" ? "" : String(m.sidearmIdx);
        sideSel.addEventListener("change", () => {
          m.sidearmIdx = sideSel.value === "" ? "" : sideSel.value;
          renderWarband();
        });

        sidearmRow.appendChild(sideSel);
        contentHost.appendChild(sidearmRow);
      }

      // Melee weapon
      const meleeSection = document.createElement("div");
      meleeSection.style.marginTop = "12px";
      meleeSection.innerHTML = "<strong>Melee Weapon</strong>";

      const meleeSel = document.createElement("select");
      meleeSel.style.width = "100%";
      meleeSel.style.marginTop = "6px";
      meleeSel.innerHTML =
        `<option value="">— None —</option>` +
        meleeWeapons.map((w, idx) => {
          const p = toIntOrNull(w.points) ?? 0;
          const nm = escapeHtml(w.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm} (${p} pts)</option>`;
        }).join("");

      meleeSel.value = m.meleeIdx === "" ? "" : String(m.meleeIdx);
      meleeSel.addEventListener("change", () => {
        m.meleeIdx = meleeSel.value === "" ? "" : meleeSel.value;
        renderWarband();
      });

      meleeSection.appendChild(meleeSel);
      contentHost.appendChild(meleeSection);
}
      contentHost.appendChild(makeSelectedWeaponsSummary(m));


      const openState = openPanelsByMember.get(memberIndex) || { accessories: false, psi: false };
if (!isPlayMode) {
      // Accessories
      const accSection = makeCollapsible("Edit Accessories", openState.accessories, (isOpen) => {
        const s = openPanelsByMember.get(memberIndex) || { accessories: false, psi: false };
        s.accessories = isOpen;
        openPanelsByMember.set(memberIndex, s);
      });
      const accWrap = accSection.body;

      const accCap = DEFENSE_TO_ACC_CAP[m.defense] ?? 0;
      const accUsed = (m.accessoryIdx || []).length;

      const capLine = document.createElement("div");
      capLine.style.marginTop = "6px";
      capLine.innerHTML = accUsed > accCap
        ? `<span style="color:#8a1f11; font-weight:700;">Over capacity: ${accUsed}/${accCap}</span>`
        : `<span style="color:#444;">Capacity: ${accUsed}/${accCap}</span>`;
      accWrap.appendChild(capLine);

      const list = document.createElement("div");
      list.style.marginTop = "6px";

      const selected = new Set((m.accessoryIdx || []).map(String));
      accessories.forEach((a, idx) => {
        const p = toIntOrNull(a.points) ?? 0;
        const name = a.name ?? "(Unnamed)";
        const id = `m${memberIndex}_a${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = selected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.accessoryIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.accessoryIdx = [...s].map(Number);
          renderWarband();
        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${p} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        list.appendChild(line);
      });

      accWrap.appendChild(list);
      contentHost.appendChild(accSection.wrap);
}
      contentHost.appendChild(makeSelectedAccessoriesSummary(m));

      if (!isPlayMode) {

      // Psychic Powers + Mutations
      const psiSection = makeCollapsible("Edit Psychic / Mutations", openState.psi, (isOpen) => {
        const s = openPanelsByMember.get(memberIndex) || { accessories: false, psi: false };
        s.psi = isOpen;
        openPanelsByMember.set(memberIndex, s);
      });
      const psiWrap = psiSection.body;

      const pmCap = psychicMutationCapacity(m);
      const pmUsed = (m.psychicIdx || []).length + (m.mutationIdx || []).length;

      const pmLine = document.createElement("div");
      pmLine.style.marginTop = "6px";
      pmLine.innerHTML = pmUsed > pmCap
        ? `<span style="color:#8a1f11; font-weight:700;">Over capacity: ${pmUsed}/${pmCap}</span>`
        : `<span style="color:#444;">Capacity: ${pmUsed}/${pmCap}</span>`;
      psiWrap.appendChild(pmLine);

      // Psychic list
      const psyTitle = document.createElement("div");
      psyTitle.style.marginTop = "8px";
      psyTitle.innerHTML = "<strong style='font-size:13px;'>Psychic Powers</strong>";
      psiWrap.appendChild(psyTitle);

      const psyList = document.createElement("div");
      psyList.style.marginTop = "6px";

      const psySelected = new Set((m.psychicIdx || []).map(String));
      psychicPowers.forEach((p, idx) => {
        const pts = toIntOrNull(p.points) ?? 0;
        const name = p.name ?? "(Unnamed)";
        const id = `m${memberIndex}_psy${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = psySelected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.psychicIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.psychicIdx = [...s].map(Number);
          renderWarband();
        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${pts} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        psyList.appendChild(line);
      });
      psiWrap.appendChild(psyList);

      // Mutations list
      const mutTitle = document.createElement("div");
      mutTitle.style.marginTop = "10px";
      mutTitle.innerHTML = "<strong style='font-size:13px;'>Mutations</strong>";
      psiWrap.appendChild(mutTitle);

      const mutList = document.createElement("div");
      mutList.style.marginTop = "6px";

      const mutSelected = new Set((m.mutationIdx || []).map(String));
      mutations.forEach((mu, idx) => {
        const pts = toIntOrNull(mu.points) ?? 0;
        const name = mu.name ?? "(Unnamed)";
        const id = `m${memberIndex}_mut${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = mutSelected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.mutationIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.mutationIdx = [...s].map(Number);
          renderWarband();
        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${pts} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        mutList.appendChild(line);
      });
      psiWrap.appendChild(mutList);
      }

      // Summary box (unchanged from your original)
      const selectedPsy = (m.psychicIdx || []).map(i => psychicPowers[Number(i)]).filter(Boolean);
      const selectedMut = (m.mutationIdx || []).map(i => mutations[Number(i)]).filter(Boolean);

      const pmSummary = document.createElement("div");
      pmSummary.style.marginTop = "10px";
      pmSummary.style.padding = "10px 12px";
      pmSummary.style.border = "1px solid #eee";
      pmSummary.style.borderRadius = "10px";
      pmSummary.style.background = "#fafafa";
      pmSummary.style.fontSize = "13px";

      const pmHead = document.createElement("div");
      pmHead.style.fontWeight = "900";
      pmHead.textContent = "Selected Powers / Mutations";
      pmSummary.appendChild(pmHead);

      const addGroup = (groupTitle, arr) => {
        const t = document.createElement("div");
        t.style.marginTop = "8px";
        t.style.fontWeight = "800";
        t.textContent = groupTitle;
        pmSummary.appendChild(t);

        if (!arr.length) {
          const none = document.createElement("div");
          none.style.marginTop = "4px";
          none.style.color = "#666";
          none.textContent = "—";
          pmSummary.appendChild(none);
          return;
        }

        arr.forEach(obj => {
          const line = document.createElement("div");
          line.style.marginTop = "6px";
          line.style.whiteSpace = "pre-wrap";

          const nm = obj.name ?? "(Unnamed)";
          const pts = toIntOrNull(obj.points) ?? 0;
          const extra = getTextField(obj, ["power_type", "type"]) || getTextField(obj, ["range"]) || "";
          const eff = getTextField(obj, ["effect_text", "effect", "rule_text"]);
          line.textContent = `${nm} (${pts} pts)${extra ? " — " + extra : ""}${eff ? " — " + eff : ""}`.trim();
          pmSummary.appendChild(line);
        });
      };

      addGroup("Psychic Powers", selectedPsy);
      addGroup("Mutations", selectedMut);

      contentHost.appendChild(psiSection.wrap);
      contentHost.appendChild(pmSummary);

      els.warbandGrid.appendChild(outer);

    });

    const total = warbandTotalPoints();
    els.warbandTotal.textContent = String(total);

    const cap = warband.pointCap;
    if (total > cap) {
      els.warbandCapStatus.innerHTML = `<span style="color:#8a1f11; font-weight:600;">Over cap by ${total - cap}</span>`;
    } else {
      els.warbandCapStatus.innerHTML = `<span style="color:#0b5; font-weight:600;">Within cap (${cap - total} left)</span>`;
    }
  }

  function exportWarband() {
    warband.pointCap = toIntOrNull(els.pointCap.value) ?? 0;
    // NEW: make sure in-play fields are present before exporting
    warband.members.forEach(ensurePlayState);
    setIoVisible(true, "Export Warband");
    els.ioText.value = JSON.stringify(warband, null, 2);
    els.ioMsg.textContent = "Copy this JSON to save/share the warband.";
  }

  function importWarbandUI() {
    setIoVisible(true, "Import Warband");
    els.ioText.value = "";
    els.ioMsg.textContent = "Paste a previously exported warband JSON, then click “Load Pasted JSON”.";
  }

  function loadPastedWarband() {
    try {
      const parsed = JSON.parse(els.ioText.value);
      if (!parsed || typeof parsed !== "object") throw new Error("Not an object");
      if (!Array.isArray(parsed.members)) throw new Error("Missing members[]");

      warband.version = parsed.version ?? warband.version;
      warband.pointCap = toIntOrNull(parsed.pointCap) ?? (toIntOrNull(els.pointCap.value) ?? warband.pointCap);

      warband.name = String(parsed.name ?? warband.name ?? "");
      if (els.warbandName) els.warbandName.value = warband.name ?? "";

      warband.warbandTraitIdx = (parsed.warbandTraitIdx === "" || parsed.warbandTraitIdx === null || parsed.warbandTraitIdx === undefined)
        ? "" : String(parsed.warbandTraitIdx);

      warband.leaderTraitIdx = (parsed.leaderTraitIdx === "" || parsed.leaderTraitIdx === null || parsed.leaderTraitIdx === undefined)
        ? "" : String(parsed.leaderTraitIdx);

      const defaultMembers = warband.members.map(m => ({
        ...m,
        weaponIdx: "", sidearmIdx: "", meleeIdx: "", accessoryIdx: [], psychicIdx: [], mutationIdx: [],
        woundsCurrent: null, horror: 0, hidden: false
      }));
      const incoming = parsed.members.slice(0, defaultMembers.length);

      warband.members = defaultMembers.map((def, i) => {
        const inc = incoming[i] ?? {};
        const merged = {
          role: def.role,
          name: String(inc.name ?? def.name ?? ""),
          defense: toIntOrNull(inc.defense) ?? def.defense,
          shoot: toIntOrNull(inc.shoot) ?? def.shoot,
          fight: toIntOrNull(inc.fight) ?? def.fight,
          will: toIntOrNull(inc.will) ?? def.will,
          weaponIdx: (inc.weaponIdx === "" || inc.weaponIdx === null || inc.weaponIdx === undefined) ? "" : String(inc.weaponIdx),
          sidearmIdx: (inc.sidearmIdx === "" || inc.sidearmIdx === null || inc.sidearmIdx === undefined) ? "" : String(inc.sidearmIdx),
          meleeIdx: (inc.meleeIdx === "" || inc.meleeIdx === null || inc.meleeIdx === undefined) ? "" : String(inc.meleeIdx),
          accessoryIdx: Array.isArray(inc.accessoryIdx) ? inc.accessoryIdx.map(Number).filter(n => Number.isFinite(n)) : [],
          psychicIdx: Array.isArray(inc.psychicIdx) ? inc.psychicIdx.map(Number).filter(n => Number.isFinite(n)) : [],
          mutationIdx: Array.isArray(inc.mutationIdx) ? inc.mutationIdx.map(Number).filter(n => Number.isFinite(n)) : [],
          // NEW: in-play fields (optional in older exports)
          woundsCurrent: toIntOrNull(inc.woundsCurrent),
          horror: toIntOrNull(inc.horror) ?? 0,
          hidden: (typeof inc.hidden === "boolean") ? inc.hidden : false,
        };
        ensurePlayState(merged);
        return merged;
      });

      els.pointCap.value = String(warband.pointCap);
      if (els.warbandTraitSelect) els.warbandTraitSelect.value = warband.warbandTraitIdx === "" ? "" : String(warband.warbandTraitIdx);
      if (els.leaderTraitSelect) els.leaderTraitSelect.value = warband.leaderTraitIdx === "" ? "" : String(warband.leaderTraitIdx);

      renderTraitDescriptions();
      renderWarband();
      els.ioMsg.textContent = "Loaded warband successfully.";
    } catch (e) {
      els.ioMsg.textContent = `Import failed: ${String(e.message || e)}`;
    }
  }

  async function loadData() {
    try {
      const wRes = await fetch("./data/shoot.json", { cache: "no-store" });
      if (!wRes.ok) throw new Error(`HTTP ${wRes.status} when fetching shoot.json`);
      weapons = await wRes.json();
      if (!Array.isArray(weapons)) throw new Error("shoot.json must be an array of objects");

      const aRes = await fetch("./data/accessories.json", { cache: "no-store" });
      if (!aRes.ok) throw new Error(`HTTP ${aRes.status} when fetching accessories.json`);
      accessories = await aRes.json();
      if (!Array.isArray(accessories)) throw new Error("accessories.json must be an array of objects");

      const fRes = await fetch("./data/fight.json", { cache: "no-store" });
      if (!fRes.ok) throw new Error(`HTTP ${fRes.status} when fetching fight.json`);
      meleeWeapons = await fRes.json();
      if (!Array.isArray(meleeWeapons)) throw new Error("fight.json must be an array of objects");

      const pRes = await fetch("./data/psychic_powers.json", { cache: "no-store" });
      if (!pRes.ok) throw new Error(`HTTP ${pRes.status} when fetching psychic_powers.json`);
      psychicPowers = await pRes.json();
      if (!Array.isArray(psychicPowers)) throw new Error("psychic_powers.json must be an array of objects");

      const mRes = await fetch("./data/mutations.json", { cache: "no-store" });
      if (!mRes.ok) throw new Error(`HTTP ${mRes.status} when fetching mutations.json`);
      mutations = await mRes.json();
      if (!Array.isArray(mutations)) throw new Error("mutations.json must be an array of objects");

      const wtRes = await fetch("./data/warband_traits.json", { cache: "no-store" });
      if (!wtRes.ok) throw new Error(`HTTP ${wtRes.status} when fetching warband_traits.json`);
      warbandTraits = await wtRes.json();
      if (!Array.isArray(warbandTraits)) throw new Error("warband_traits.json must be an array of objects");

      const ltRes = await fetch("./data/leader_traits.json", { cache: "no-store" });
      if (!ltRes.ok) throw new Error(`HTTP ${ltRes.status} when fetching leader_traits.json`);
      leaderTraits = await ltRes.json();
      if (!Array.isArray(leaderTraits)) throw new Error("leader_traits.json must be an array of objects");

      weapons.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      accessories.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      psychicPowers.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      mutations.sort((a, b) =>
        ((toIntOrNull(b.points) ?? 0) - (toIntOrNull(a.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      meleeWeapons.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );

      warbandTraits.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      leaderTraits.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );

      // IO buttons
      els.exportBtn.addEventListener("click", exportWarband);
      els.importBtn.addEventListener("click", importWarbandUI);
      els.closeIoBtn.addEventListener("click", () => setIoVisible(false));
      els.copyBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(els.ioText.value);
          els.ioMsg.textContent = "Copied to clipboard.";
        } catch {
          els.ioMsg.textContent = "Could not copy automatically — select all and copy manually.";
        }
      });
      els.loadBtn.addEventListener("click", loadPastedWarband);

      // Warband Trait select
      els.warbandTraitSelect.innerHTML =
        `<option value="">— None —</option>` +
        warbandTraits.map((t, idx) => {
          const nm = escapeHtml(t.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm}</option>`;
        }).join("");
      els.warbandTraitSelect.value = warband.warbandTraitIdx === "" ? "" : String(warband.warbandTraitIdx);
      renderTraitDescriptions();
      els.warbandTraitSelect.addEventListener("change", () => {
        warband.warbandTraitIdx = els.warbandTraitSelect.value === "" ? "" : els.warbandTraitSelect.value;
        renderTraitDescriptions();
        renderWarband();
      });

      // Leader Trait select
      els.leaderTraitSelect.innerHTML =
        `<option value="">— None —</option>` +
        leaderTraits.map((t, idx) => {
          const nm = escapeHtml(t.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm}</option>`;
        }).join("");
      els.leaderTraitSelect.value = warband.leaderTraitIdx === "" ? "" : String(warband.leaderTraitIdx);
      renderTraitDescriptions();
      els.leaderTraitSelect.addEventListener("change", () => {
        warband.leaderTraitIdx = els.leaderTraitSelect.value === "" ? "" : els.leaderTraitSelect.value;
        renderTraitDescriptions();
        renderWarband();
      });

      // Warband name input
      if (els.warbandName) {
        els.warbandName.value = warband.name ?? "";
        els.warbandName.addEventListener("input", () => { warband.name = els.warbandName.value; });
      }

      // Compact mode toggle (persisted)
      loadCompactPref();
      applyCompactMode(uiPrefs.compact);
      if (els.compactToggle) {
        els.compactToggle.checked = uiPrefs.compact;
        els.compactToggle.addEventListener("change", () => applyCompactMode(els.compactToggle.checked));
      }

      // Dice Tray
      if (els.rollD20Btn && els.d20Result) {
        els.rollD20Btn.addEventListener("click", () => {
          els.rollD20Btn.disabled = true;

          els.d20Result.classList.remove("dice-rolling");
          void els.d20Result.offsetWidth;
          els.d20Result.classList.add("dice-rolling");

          const start = Date.now();
          const flicker = setInterval(() => {
            els.d20Result.textContent = String(rollDie(20));
            if (Date.now() - start > 350) clearInterval(flicker);
          }, 45);

          setTimeout(() => {
            const r = rollDie(20);
            els.d20Result.textContent = String(r);

            diceState.history.unshift(r);
            diceState.history = diceState.history.slice(0, 10);
            renderDice();

            els.rollD20Btn.disabled = false;
          }, 380);
        });
      }

      // Clear dice
      if (els.clearRollsBtn) {
        els.clearRollsBtn.addEventListener("click", () => {
          diceState.history = [];
          if (els.d20Result) els.d20Result.textContent = "—";
          renderDice();
        });
      }

      renderDice();

      // Ensure play state defaults
      warband.members.forEach(ensurePlayState);

      renderWarband();
    } catch (err) {
      els.errorCard.style.display = "block";
      els.errorText.textContent = String(err);
      console.error(err);
    }
  }

  loadData();
</script>

</body>
</html>
