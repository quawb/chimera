<!doctype html> 
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chimera — Warband Builder (Prototype)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; line-height: 1.35; }
    h1 { margin: 0 0 8px; }
    .sub { color: #444; margin: 0 0 24px; }
    .row { display: grid; grid-template-columns: 240px 1fr; gap: 12px; align-items: center; margin-bottom: 12px; }
    select, input { font-size: 16px; padding: 8px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; margin-top: 16px; max-width: 820px; }
    .grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; margin-top: 12px; }
    .pill { display: inline-block; border: 1px solid #ddd; border-radius: 999px; padding: 4px 10px; margin: 4px 6px 0 0; font-size: 14px; }
    .warn { color: #8a1f11; font-weight: 600; }
    .ok { color: #0b5; font-weight: 600; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>

<body>
  <h1>Chimera Builder (Prototype)</h1>
  <p class="sub">Loads <code>data/shoot.json</code> and <code>data/accessories.json</code>. Select a weapon + accessories and see points update.</p>
. Select a ranged weapon and see stats + points update.</p>



  <div class="row">
    <label for="pointCap"><strong>Point Cap</strong></label>
    <input id="pointCap" type="number" value="75" min="0" step="1" />
  </div>



    <div class="card">
    <div style="display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center;">
      <div>
        <div style="font-size:18px; font-weight:800;">Warband</div>
        <div style="color:#444; margin-top:4px;">Leader + 4 models. Each model has its own weapon + accessories.</div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="exportBtn" type="button">Export Warband</button>
        <button id="importBtn" type="button">Import Warband</button>
      </div>
    </div>

    <div id="warbandGrid" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; margin-top:14px;"></div>

    <div style="margin-top:14px;">
      <div style="font-size:14px; color:#444;">Warband Total</div>
      <div style="font-size:28px; font-weight:900;" id="warbandTotal">0</div>
      <div id="warbandCapStatus" style="margin-top:6px;"></div>
    </div>

    <div id="ioArea" style="display:none; margin-top:14px;">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
        <strong id="ioTitle">Export / Import</strong>
        <button id="closeIoBtn" type="button">Close</button>
      </div>
      <textarea id="ioText" rows="10" style="width:100%; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; padding:10px;"></textarea>
      <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
        <button id="copyBtn" type="button">Copy</button>
        <button id="loadBtn" type="button">Load Pasted JSON</button>
      </div>
      <div id="ioMsg" style="margin-top:8px; color:#444;"></div>
    </div>
  </div>


  <div class="card" id="errorCard" style="display:none;">
    <div class="warn">Could not load shoot.json</div>
    <p id="errorText" style="margin:8px 0 0;"></p>
    <p style="margin:8px 0 0;">
      Expected path: <code>site/data/shoot.json</code>
    </p>
  </div>

<script>
  const els = {
    pointCap: document.getElementById("pointCap"),
    warbandGrid: document.getElementById("warbandGrid"),
    warbandTotal: document.getElementById("warbandTotal"),
    warbandCapStatus: document.getElementById("warbandCapStatus"),

    exportBtn: document.getElementById("exportBtn"),
    importBtn: document.getElementById("importBtn"),
    ioArea: document.getElementById("ioArea"),
    ioTitle: document.getElementById("ioTitle"),
    ioText: document.getElementById("ioText"),
    copyBtn: document.getElementById("copyBtn"),
    loadBtn: document.getElementById("loadBtn"),
    closeIoBtn: document.getElementById("closeIoBtn"),
    ioMsg: document.getElementById("ioMsg"),

    errorCard: document.getElementById("errorCard"),
    errorText: document.getElementById("errorText"),
  };

  function toIntOrNull(v) {
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (s === "") return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function escapeHtml(str) {
    return String(str ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // Data tables (loaded from JSON)
  let weapons = [];
  let accessories = [];

  // === Rules (hardwired for now, easy to change) ===
  // Defense tier -> accessory capacity (count of accessories allowed)
  const DEFENSE_TO_ACC_CAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3
  };

  // Shoot tier threshold to unlock second sidearm slot
  const SIDEARM_UNLOCK_SHOOT_TIER = 3;

    // === Stat costs + modifiers (hard-coded) ===
  // Tier -> { mod, cost }
  // Note: using tiers 0–3 in UI, but rules define Tier 1/2/3. Tier 0 behaves like "untrained".
  const DEF_WILL_TABLE = {
    0: { mod: -2, cost: 0 }, // optional; feel free to change
    1: { mod: 0,  cost: 2 },
    2: { mod: 2,  cost: 4 },
    3: { mod: 4,  cost: 8 },
  };

  const SHOOT_FIGHT_TABLE = {
    0: { mod: -2, cost: 0 },
    1: { mod: -2, cost: 0 }, // per your rule: Tier 1 is -2 for 0 points
    2: { mod: 2,  cost: 3 },
    3: { mod: 4,  cost: 6 },
  };

  // Saving throw target by Willpower Tier (never below 10)
  const SAVE_TARGET_BY_WILL = {
    0: 14, // optional fallback; adjust if you want Tier 0 handled differently
    1: 14,
    2: 13,
    3: 11,
  };

  function clampMin(n, min) {
    return n < min ? min : n;
  }

  function defenseMod(tier) {
    return (DEF_WILL_TABLE[tier] ?? DEF_WILL_TABLE[1]).mod;
  }

  function willMod(tier) {
    return (DEF_WILL_TABLE[tier] ?? DEF_WILL_TABLE[1]).mod;
  }

  function shootMod(tier) {
    return (SHOOT_FIGHT_TABLE[tier] ?? SHOOT_FIGHT_TABLE[1]).mod;
  }

  function fightMod(tier) {
    return (SHOOT_FIGHT_TABLE[tier] ?? SHOOT_FIGHT_TABLE[1]).mod;
  }

  function statPointsCost(m) {
    const d = (DEF_WILL_TABLE[m.defense] ?? DEF_WILL_TABLE[1]).cost;
    const w = (DEF_WILL_TABLE[m.will] ?? DEF_WILL_TABLE[1]).cost;
    const s = (SHOOT_FIGHT_TABLE[m.shoot] ?? SHOOT_FIGHT_TABLE[1]).cost;
    const f = (SHOOT_FIGHT_TABLE[m.fight] ?? SHOOT_FIGHT_TABLE[1]).cost;
    return d + w + s + f;
  }

  function woundsTotal(m) {
    return (m.defense ?? 0) + (m.shoot ?? 0) + (m.fight ?? 0) + (m.will ?? 0);
  }

  function equipmentCapacity(m) {
    // Your rule: equal to Defense Tier
    return m.defense ?? 0;
  }

  function psychicMutationCapacity(m) {
    // Your rule: equal to Willpower Tier
    return m.will ?? 0;
  }

  function savingThrowTarget(m) {
    const t = SAVE_TARGET_BY_WILL[m.will] ?? SAVE_TARGET_BY_WILL[1];
    return clampMin(t, 10);
  }

  function armorClass(m) {
    // For now: no item/mutation modifiers wired, so it’s just defense modifier.
    // Later we’ll add accessory/mutation AC bonuses.
    return 10 + defenseMod(m.defense ?? 1);
  }


  // Warband state: leader + 4 models
  const warband = {
    version: 2,
    pointCap: 75,
    members: [
      { role: "Leader", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [] },
      { role: "Model 1", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [] },
      { role: "Model 2", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [] },
      { role: "Model 3", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [] },
      { role: "Model 4", defense: 1, shoot: 1, fight: 1, will: 1, weaponIdx: "", sidearmIdx: "", accessoryIdx: [] },
    ]
  };

  function memberWeaponPoints(m) {
    let sum = 0;

    if (m.weaponIdx !== "" && m.weaponIdx !== null && m.weaponIdx !== undefined) {
      const w = weapons[Number(m.weaponIdx)];
      sum += toIntOrNull(w?.points) ?? 0;
    }

    if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER &&
        m.sidearmIdx !== "" && m.sidearmIdx !== null && m.sidearmIdx !== undefined) {
      const s = weapons[Number(m.sidearmIdx)];
      sum += toIntOrNull(s?.points) ?? 0;
    }

    return sum;
  }

  function memberAccessoryPoints(m) {
    let sum = 0;
    for (const idx of (m.accessoryIdx || [])) {
      const a = accessories[Number(idx)];
      sum += (toIntOrNull(a?.points) ?? 0);
    }
    return sum;
  }

  function memberTotalPoints(m) {
  return statPointsCost(m) + memberWeaponPoints(m) + memberAccessoryPoints(m);
}


  function warbandTotalPoints() {
    return warband.members.reduce((acc, m) => acc + memberTotalPoints(m), 0);
  }

  function setIoVisible(vis, title) {
    els.ioArea.style.display = vis ? "block" : "none";
    if (title) els.ioTitle.textContent = title;
    els.ioMsg.textContent = "";
  }

  function renderWarband() {
    // Point cap
    warband.pointCap = toIntOrNull(els.pointCap.value) ?? 0;

    // Clear + rebuild grid
    els.warbandGrid.innerHTML = "";

    warband.members.forEach((m, memberIndex) => {
      const card = document.createElement("div");
      card.style.border = "1px solid #ddd";
      card.style.borderRadius = "10px";
      card.style.padding = "14px";

      // Header: role + points
      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.justifyContent = "space-between";
      header.style.alignItems = "baseline";
      header.style.gap = "10px";

      const title = document.createElement("div");
      title.style.fontWeight = "900";
      title.style.fontSize = "16px";
      title.textContent = m.role;

      const pts = document.createElement("div");
      pts.style.fontWeight = "800";
      pts.textContent = `${memberTotalPoints(m)} pts`;

      header.appendChild(title);
      header.appendChild(pts);
      card.appendChild(header);

      // Stat tier helpers
      function tierSelect(label, key) {
        const wrap = document.createElement("div");
        wrap.style.display = "grid";
        wrap.style.gridTemplateColumns = "1fr 80px";
        wrap.style.gap = "8px";
        wrap.style.alignItems = "center";

        const l = document.createElement("div");
        l.innerHTML = `<strong>${escapeHtml(label)}</strong>`;

        const s = document.createElement("select");
        
                const tiers = [1, 2, 3];

        const table =
          (key === "defense" || key === "will") ? DEF_WILL_TABLE :
          (key === "shoot" || key === "fight") ? SHOOT_FIGHT_TABLE :
          null;

        s.innerHTML = tiers.map(t => {
          const entry = table?.[t];
          const mod = entry?.mod ?? 0;
          const cost = entry?.cost ?? 0;

          // Example: "Tier 2 (+2, 4 pts)"
          const modStr = mod >= 0 ? `+${mod}` : `${mod}`;
          return `<option value="${t}">Tier ${t} (${modStr}, ${cost} pts)</option>`;
        }).join("");

        
        s.value = String(m[key] ?? 0);

        s.addEventListener("change", () => {
          m[key] = Number(s.value);

          // If shoot tier drops below unlock, clear sidearm selection
          if (key === "shoot" && (m.shoot ?? 0) < SIDEARM_UNLOCK_SHOOT_TIER) {
            m.sidearmIdx = "";
          }
          renderWarband();
        });

        wrap.appendChild(l);
        wrap.appendChild(s);
        return wrap;
      }

      // Stats block
      const statsBlock = document.createElement("div");
      statsBlock.style.marginTop = "10px";
      statsBlock.style.display = "grid";
      statsBlock.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
      statsBlock.style.gap = "10px";

      statsBlock.appendChild(tierSelect("Defense", "defense"));
      statsBlock.appendChild(tierSelect("Shoot", "shoot"));
      statsBlock.appendChild(tierSelect("Fight", "fight"));
      statsBlock.appendChild(tierSelect("Willpower", "will"));
      card.appendChild(statsBlock);

            // Derived stats panel
      const derived = document.createElement("div");
      derived.style.marginTop = "10px";
      derived.style.padding = "10px";
      derived.style.border = "1px solid #eee";
      derived.style.borderRadius = "10px";
      derived.style.background = "#fafafa";

      const statLine = (label, value) => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.justifyContent = "space-between";
        row.style.gap = "12px";
        row.style.marginTop = "4px";
        row.innerHTML = `<span style="color:#444;">${escapeHtml(label)}</span><span style="font-weight:700;">${escapeHtml(value)}</span>`;
        return row;
      };

      // Calculations
      const ac = armorClass(m);
      const saveT = savingThrowTarget(m);
      const wounds = woundsTotal(m);

      const eqCap = equipmentCapacity(m);
      const eqUsed = (m.accessoryIdx || []).length;

      const pmCap = psychicMutationCapacity(m); // willpower-tier based
      const statCost = statPointsCost(m);

      derived.appendChild(statLine("Armor Class (AC)", String(ac)));
      derived.appendChild(statLine("Saving Throw Target", String(saveT)));
      derived.appendChild(statLine("Wounds", String(wounds)));

      derived.appendChild(statLine("Equipment Capacity", `${eqUsed}/${eqCap}`));
      derived.appendChild(statLine("Psychic/Mutation Capacity", String(pmCap)));

      derived.appendChild(statLine("Stat Points", String(statCost)));

      card.appendChild(derived);


      // Primary weapon select
      const weaponRow = document.createElement("div");
      weaponRow.style.marginTop = "12px";
      weaponRow.innerHTML = "<strong>Ranged Weapon</strong>";

      const sel = document.createElement("select");
      sel.style.width = "100%";
      sel.style.marginTop = "6px";
      sel.innerHTML =
        `<option value="">— None —</option>` +
        weapons.map((w, idx) => {
          const p = toIntOrNull(w.points) ?? 0;
          const nm = escapeHtml(w.name ?? "(Unnamed)");
          return `<option value="${idx}">${nm} (${p} pts)</option>`;
        }).join("");

      sel.value = m.weaponIdx === "" ? "" : String(m.weaponIdx);
      sel.addEventListener("change", () => {
        m.weaponIdx = sel.value === "" ? "" : sel.value;
        renderWarband();
      });

      weaponRow.appendChild(sel);
      card.appendChild(weaponRow);

      // Secondary sidearm select (Shoot >= 3)
      if ((m.shoot ?? 0) >= SIDEARM_UNLOCK_SHOOT_TIER) {
        const sidearmRow = document.createElement("div");
        sidearmRow.style.marginTop = "10px";
        sidearmRow.innerHTML = "<strong>Sidearm (Shoot Tier 3+)</strong>";

        // TEMP: detect sidearms by name (later: add category column in shoot.csv)
        const sidearms = weapons
          .map((w, idx) => ({ w, idx }))
          .filter(x =>
            String(x.w.name ?? "").toLowerCase().includes("sidearm") ||
            String(x.w.name ?? "").toLowerCase().includes("pistol")
          );

        const sideSel = document.createElement("select");
        sideSel.style.width = "100%";
        sideSel.style.marginTop = "6px";
        sideSel.innerHTML =
          `<option value="">— None —</option>` +
          sidearms.map(x => {
            const p = toIntOrNull(x.w.points) ?? 0;
            const nm = escapeHtml(x.w.name ?? "(Unnamed)");
            return `<option value="${x.idx}">${nm} (${p} pts)</option>`;
          }).join("");

        sideSel.value = m.sidearmIdx === "" ? "" : String(m.sidearmIdx);
        sideSel.addEventListener("change", () => {
          m.sidearmIdx = sideSel.value === "" ? "" : sideSel.value;
          renderWarband();
        });

        sidearmRow.appendChild(sideSel);
        card.appendChild(sidearmRow);
      }

      // Accessories (checkboxes)
      const accWrap = document.createElement("div");
      accWrap.style.marginTop = "12px";
      accWrap.innerHTML = "<strong>Accessories</strong>";

      const cap = DEFENSE_TO_ACC_CAP[m.defense] ?? 0;
      const used = (m.accessoryIdx || []).length;

      const capLine = document.createElement("div");
      capLine.style.marginTop = "6px";
      capLine.innerHTML = used > cap
        ? `<span style="color:#8a1f11; font-weight:700;">Over capacity: ${used}/${cap}</span>`
        : `<span style="color:#444;">Capacity: ${used}/${cap}</span>`;
      accWrap.appendChild(capLine);

      const list = document.createElement("div");
      list.style.marginTop = "6px";

      const selected = new Set((m.accessoryIdx || []).map(String));
      accessories.forEach((a, idx) => {
        const p = toIntOrNull(a.points) ?? 0;
        const name = a.name ?? "(Unnamed)";
        const id = `m${memberIndex}_a${idx}`;

        const line = document.createElement("div");
        line.style.marginBottom = "6px";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.checked = selected.has(String(idx));
        cb.addEventListener("change", () => {
          const s = new Set((m.accessoryIdx || []).map(String));
          if (cb.checked) s.add(String(idx));
          else s.delete(String(idx));
          m.accessoryIdx = [...s].map(Number);
          renderWarband();
        });

        const lbl = document.createElement("label");
        lbl.htmlFor = id;
        lbl.style.cursor = "pointer";
        lbl.textContent = ` ${name} (${p} pts)`;

        line.appendChild(cb);
        line.appendChild(lbl);
        list.appendChild(line);
      });

      accWrap.appendChild(list);
      card.appendChild(accWrap);

      els.warbandGrid.appendChild(card);
    });

    // Warband totals
    const total = warbandTotalPoints();
    els.warbandTotal.textContent = String(total);

    const cap = warband.pointCap;
    if (total > cap) {
      els.warbandCapStatus.innerHTML = `<span style="color:#8a1f11; font-weight:600;">Over cap by ${total - cap}</span>`;
    } else {
      els.warbandCapStatus.innerHTML = `<span style="color:#0b5; font-weight:600;">Within cap (${cap - total} left)</span>`;
    }
  }

  function exportWarband() {
    warband.pointCap = toIntOrNull(els.pointCap.value) ?? 0;
    setIoVisible(true, "Export Warband");
    els.ioText.value = JSON.stringify(warband, null, 2);
    els.ioMsg.textContent = "Copy this JSON to save/share the warband.";
  }

  function importWarbandUI() {
    setIoVisible(true, "Import Warband");
    els.ioText.value = "";
    els.ioMsg.textContent = "Paste a previously exported warband JSON, then click “Load Pasted JSON”.";
  }

  function loadPastedWarband() {
    try {
      const parsed = JSON.parse(els.ioText.value);
      if (!parsed || typeof parsed !== "object") throw new Error("Not an object");
      if (!Array.isArray(parsed.members)) throw new Error("Missing members[]");

      warband.version = parsed.version ?? warband.version;
      warband.pointCap = toIntOrNull(parsed.pointCap) ?? (toIntOrNull(els.pointCap.value) ?? warband.pointCap);

      const defaultMembers = warband.members.map(m => ({ ...m, weaponIdx: "", sidearmIdx: "", accessoryIdx: [] }));
      const incoming = parsed.members.slice(0, defaultMembers.length);

      warband.members = defaultMembers.map((def, i) => {
        const inc = incoming[i] ?? {};
        return {
          role: def.role,
          defense: toIntOrNull(inc.defense) ?? def.defense,
          shoot: toIntOrNull(inc.shoot) ?? def.shoot,
          fight: toIntOrNull(inc.fight) ?? def.fight,
          will: toIntOrNull(inc.will) ?? def.will,
          weaponIdx: (inc.weaponIdx === "" || inc.weaponIdx === null || inc.weaponIdx === undefined) ? "" : String(inc.weaponIdx),
          sidearmIdx: (inc.sidearmIdx === "" || inc.sidearmIdx === null || inc.sidearmIdx === undefined) ? "" : String(inc.sidearmIdx),
          accessoryIdx: Array.isArray(inc.accessoryIdx) ? inc.accessoryIdx.map(Number).filter(n => Number.isFinite(n)) : [],
        };
      });

      els.pointCap.value = String(warband.pointCap);
      renderWarband();
      els.ioMsg.textContent = "Loaded warband successfully.";
    } catch (e) {
      els.ioMsg.textContent = `Import failed: ${String(e.message || e)}`;
    }
  }

  async function loadData() {
    try {
      const wRes = await fetch("./data/shoot.json", { cache: "no-store" });
      if (!wRes.ok) throw new Error(`HTTP ${wRes.status} when fetching shoot.json`);
      weapons = await wRes.json();
      if (!Array.isArray(weapons)) throw new Error("shoot.json must be an array of objects");

      const aRes = await fetch("./data/accessories.json", { cache: "no-store" });
      if (!aRes.ok) throw new Error(`HTTP ${aRes.status} when fetching accessories.json`);
      accessories = await aRes.json();
      if (!Array.isArray(accessories)) throw new Error("accessories.json must be an array of objects");

      weapons.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );
      accessories.sort((a, b) =>
        ((toIntOrNull(a.points) ?? 0) - (toIntOrNull(b.points) ?? 0)) ||
        String(a.name ?? "").localeCompare(String(b.name ?? ""))
      );

      // Wire IO buttons
      els.exportBtn.addEventListener("click", exportWarband);
      els.importBtn.addEventListener("click", importWarbandUI);
      els.closeIoBtn.addEventListener("click", () => setIoVisible(false));
      els.copyBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(els.ioText.value);
          els.ioMsg.textContent = "Copied to clipboard.";
        } catch {
          els.ioMsg.textContent = "Could not copy automatically — select all and copy manually.";
        }
      });
      els.loadBtn.addEventListener("click", loadPastedWarband);

      // Initial render
      renderWarband();

    } catch (err) {
      els.errorCard.style.display = "block";
      els.errorText.textContent = String(err);
      console.error(err);
    }
  }

  loadData();
</script>

</body>
</html>
